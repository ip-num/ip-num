{"version":3,"file":"./ip-num.js","mappings":"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","sources":["webpack://ipnum/./src/BinaryUtils.ts","webpack://ipnum/./src/index.ts","webpack://ipnum/./src/IPNumber.ts","webpack://ipnum/./src/IPRange.ts","webpack://ipnum/./src/HexadecimalUtils.ts","webpack://ipnum/./src/IPPool.ts","webpack://ipnum/./src/Prefix.ts","webpack://ipnum/./src/Validator.ts","webpack://ipnum/./src/Octet.ts","webpack://ipnum/./src/IPv6Utils.ts","webpack://ipnum/./src/Hexadecatet.ts","webpack://ipnum/webpack/bootstrap","webpack://ipnum/webpack/startup"],"sourcesContent":["import {IPNumType} from \"./IPNumType\";\n\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\n\nexport let numberToBinaryString = (num: number | bigint): string => {\n    return num.toString(2);\n};\n\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexport let decimalNumberToOctetString = (num: number | bigint): string => {\n    let binaryString = numberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\")\n    }\n    return leftPadWithZeroBit(binaryString, 8);\n};\n\n/**\n * Parses number in binary to number in BigInt\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInt\n */\nexport let parseBinaryStringToBigInt = (num: string): bigint => {\n    return BigInt(`0b${num}`);\n};\n\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexport let dottedDecimalNotationToBinaryString = (dottedDecimal: string): string => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexport let leftPadWithZeroBit = (binaryString: string, finalStringLength: number): string => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than given final length after padding: ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n\n/**\n * Given the prefix portion of a cidr notation and the type of IP number, returns the mask in binary string\n *\n * @param {number} cidrPrefix the prefix part of a cidr notation\n * @param {IPNumType.IPv4 | IPNumType.IPv6} ipType the type of the ip number in the range the cidr represents\n */\nexport let cidrPrefixToMaskBinaryString = (cidrPrefix: number, ipType: IPNumType.IPv4 | IPNumType.IPv6): string => {\n  let cidrUpperValue;\n  if (ipType == IPNumType.IPv4) {\n    cidrUpperValue = 32;\n  } else {\n    cidrUpperValue = 128\n  }\n  if (cidrPrefix > cidrUpperValue) throw Error(`Value is greater than ${cidrUpperValue}`);\n\n  let onBits = '1'.repeat(cidrPrefix);\n  let offBits = '0'.repeat(cidrUpperValue - cidrPrefix);\n  return `${onBits}${offBits}`;\n};\n\n/**\n * Calculates the log, to base 2 of given number.\n *\n * @throws Error if number cannot be converted to log base 2\n * @param givenNumber the number to calculate log base 2\n * @return the log base 2 of given number\n */\nexport let intLog2 = (givenNumber: bigint): number => {\n    let result = 0;\n\n    while (givenNumber % 2n === 0n) {\n        if (givenNumber === 2n) {\n            result++;\n            break;\n        }\n        givenNumber = givenNumber >> 1n;\n        if (givenNumber % 2n !== 0n) {\n            result = 0;\n            break;\n        }\n        result++;\n    }\n\n    if (result == 0) {\n        throw new Error(`The value of log2 for ${givenNumber.toString()} is not an integer`)\n    }\n    return result\n};\n\n/**\n * Starting from the most significant bit (from left) returns the number of first bits from both string that are equal\n * @param firstBinaryString first binary string\n * @param secondBinaryString second binary string\n */\nexport let matchingBitCount = (firstBinaryString: string, secondBinaryString: string) : number => {\n    let longerString;\n    let otherString;\n\n    if (firstBinaryString.length >= secondBinaryString.length) {\n        longerString = firstBinaryString;\n        otherString = secondBinaryString;\n    } else {\n        longerString = secondBinaryString;\n        otherString = firstBinaryString;\n    }\n\n    let count = 0;\n    for (;count < longerString.length; count++) {\n        if (longerString.charAt(count) === otherString.charAt(count)) {\n            continue;\n        }\n        break;\n    }\n    return count;\n};","/**\n * Exposes all the library's modules making them available from the \"ip-num\" module.\n * Making it possible to get access to all any of the modules by doing require(\"ip-num\")\n *\n * @example\n * let ipNum = require(\"ip-num\")\n * ipNum.IPv4CidrRange // gets access to IPv4CidrRange\n * ipNum.Asn // gets access to Asn\n */\nexport * from './BinaryUtils'\nexport * from './Hexadecatet'\nexport * from './HexadecimalUtils'\nexport * from './IPNumber'\nexport * from './IPNumType'\nexport * from './IPPool'\nexport * from './IPRange'\nexport * from './IPv6Utils'\nexport * from './Octet'\nexport * from './Prefix'\nexport * from './Validator'","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInt} from \"./BinaryUtils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {numberToBinaryString} from \"./BinaryUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {hexadectetNotationToBinaryString} from \"./HexadecimalUtils\";\n\n\n/**\n * Provides the implementation of functionality that are common\n * to {@link IPv4}, {@link IPv6}, {@link IPv4Mask} and {@link IPv6Mask}\n */\nexport abstract class AbstractIPNum {\n    /**\n     * The decimal value represented by the IP number in BigInt\n     */\n    abstract readonly value: bigint;\n    /**\n     * The number of bits needed to represent the value of the IP number\n     */\n    abstract readonly bitSize: number;\n    /**\n     * The maximum bit size (i.e. binary value) of the IP number in BigInt\n     */\n    abstract readonly maximumBitSize: bigint;\n\n    abstract nextIPNumber(): AbstractIPNum;\n    abstract previousIPNumber(): AbstractIPNum;\n\n    /**\n     * Gets the numeric value of an IP number as {@link BigInt}\n     *\n     * @returns bigInt the numeric value of an IP number.\n     */\n    public getValue(): bigint {\n        return this.value;\n    }\n\n    /**\n     * Gets the binary string representation of an IP number.\n     *\n     * @returns {string} the string binary representation.\n     */\n    public toBinaryString(): string {\n        return leftPadWithZeroBit(this.value.toString(2), this.bitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value greater than the present value\n     * @returns {boolean} true, if there is a value greater than the present value. Returns false otherwise.\n     */\n    hasNext(): boolean {\n        return this.value < this.maximumBitSize;\n    }\n\n    /**\n     * Checks if an IP number has a value lesser than the present value\n     * @returns {boolean} true, if there is a value lesser than the present value. Returns false otherwise.\n     */\n    hasPrevious():boolean {\n        return this.value > 0n;\n    }\n\n    /**\n     * Checks if the given IP number, is equals to the current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is equals\n     */\n    public isEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value === anotherIPNum.value;\n    }\n\n    /**\n     * Checks if the given IP number is lesser than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than this current one. False otherwise.\n     */\n    public isLessThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value < anotherIPNum.value;\n    }\n\n    /**\n     * Checks if the given IP number is greater than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is greater than this current one. False otherwise.\n     */\n    public isGreaterThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value > anotherIPNum.value;\n    }\n\n    /**\n     * Checks if the given IP number is less than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than or equals to this current one. False otherwise.\n     */\n    public isLessThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value <= anotherIPNum.value;\n    }\n\n    /**\n     * Checks if the given IP number is greater than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} {boolean} true if the given IP number is greater than or equals to this current one. False\n     * otherwise.\n     */\n    public isGreaterThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value >= anotherIPNum.value;\n    }\n}\n\n/**\n * Represents an IPv4 number. A 32 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv4\n * @see https://www.rfc-editor.org/info/rfc791\n */\nexport class IPv4 extends AbstractIPNum {\n    /**\n     * The decimal value represented by the IPv4 number in BigInt\n     */\n    readonly value: bigint;\n    /**\n     * The number of bits needed to represents the value of the IPv4 number\n     */\n    readonly bitSize: number = 32;\n\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv4 number in BigInt\n     */\n    readonly maximumBitSize: bigint = Validator.THIRTY_TWO_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv4;\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4 number\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The string character used to separate the individual octets when the IPv4 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual octets when rendered as strings\n     */\n    readonly separator: string = \".\";\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the decimal value of the IP number in BigInt\n     *\n     * @param {bigint} bigIntValue the decimal value of the IP number in BigInt\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromNumber(bigIntValue: bigint | number): IPv4 {\n        return new IPv4(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the IP number in dot-decimal notation. E.g\n     * \"10.1.1.10\"\n     *\n     * {@see https://en.wikipedia.org/wiki/Dot-decimal_notation} for more information on dot-decimal notation.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromDecimalDottedString(ipString: string) : IPv4 {\n        return new IPv4(ipString);\n    }\n\n    /**\n     * Alias for IPv4.fromDecimalDottedString.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromString(ipString: string): IPv4 {\n        return IPv4.fromDecimalDottedString(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv4 number to be created\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv4 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            return new IPv4(parseBinaryStringToBigInt(ipBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an IPv4 number.\n     *\n     * @param {string | bigint} ipValue value to construct an IPv4 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in dot-decimal notation\n     */\n    constructor(ipValue: string | bigint | number) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let [value, octets] = this.constructFromDecimalDottedString(ipValue);\n            this.value = value;\n            this.octets = octets\n        } else {\n            let [value, octets] = this.constructFromBigIntValue(ipValue);\n            this.value = value;\n            this.octets = octets;\n        }\n    }\n\n    /**\n     * A string representation of the IPv4 number. The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map((value) => { return value.toString()}).join(this.separator);\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 number\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 number\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n\n    /**\n     * Returns the next IPv4 number\n     *\n     * @returns {IPv4} the next IPv4 number\n     */\n    public nextIPNumber(): IPv4 {\n        return IPv4.fromNumber(this.getValue() + 1n)\n    }\n\n    /**\n     * Returns the previous IPv4 number\n     *\n     * @returns {IPv4} the previous IPv4 number\n     */\n    public previousIPNumber(): IPv4 {\n        return IPv4.fromNumber(this.getValue() - 1n)\n    }\n\n    /**\n     * Returns this IPv4 number as a IPv4-Mapped IPv6 Address\n     *\n     * The IPv4-Mapped IPv6 Address allows an IPv4 number to be embedded within an IPv6 number\n     *\n     * {@see https://tools.ietf.org/html/rfc4291#section-2.5.5} for more information on the IPv4-Mapped IPv6 Address\n     *\n     * @returns {IPv6} an IPv6 number with the IPv4 embedded within it\n     */\n    public toIPv4MappedIPv6(): IPv6 {\n        let binary = '1'.repeat(16) + this.toBinaryString();\n        return IPv6.fromBinaryString(binary);\n    }\n\n\n    private constructFromDecimalDottedString(ipString: string): [bigint, Array<Octet>] {\n        let octets;\n        let value;\n        let [isValid, message] = Validator.isValidIPv4String(ipString);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let stringOctets = ipString.split(\".\");\n        octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        value = BigInt(`0b${dottedDecimalNotationToBinaryString(ipString)}`);\n        return [value, octets]\n    }\n\n    private constructFromBigIntValue(ipv4Number: bigint | number): [bigint, Array<Octet>]  {\n        let [isValid, message] = Validator.isValidIPv4Number(ipv4Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let binaryString = numberToBinaryString(ipv4Number);\n        ipv4Number = typeof ipv4Number === \"bigint\" ? ipv4Number : BigInt(ipv4Number);\n        return [ipv4Number, this.binaryStringToDecimalOctets(binaryString)]\n    }\n\n    private binaryStringToDecimalOctets(ipv4BinaryString: string): Array<Octet> {\n        if (ipv4BinaryString.length < 32) {\n            ipv4BinaryString = leftPadWithZeroBit(ipv4BinaryString, 32);\n        }\n        let octets: string[] = ipv4BinaryString.match(/.{1,8}/g)!;\n        return octets.map((octet) => {\n            return Octet.fromString(parseBinaryStringToBigInt(octet).toString())\n        });\n    }\n}\n\n\n\n\n/**\n * Represents an Autonomous System Number. Which is a number that is used to identify\n * a group of IP addresses with a common, clearly defined routing policy.\n *\n * @see https://en.wikipedia.org/wiki/Autonomous_system_(Internet)\n * @see https://tools.ietf.org/html/rfc5396\n */\nexport class Asn extends AbstractIPNum {\n    /**\n     * The decimal value represented by the ASN number in BigInt\n     */\n    readonly value: bigint;\n    /**\n     * The number of bits needed to represents the value of the ASN number\n     */\n    bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the ASN number in BigInt\n     */\n    maximumBitSize: bigint = Validator.THIRTY_TWO_BIT_SIZE;\n\n    type: IPNumType = IPNumType.ASN;\n    private static AS_PREFIX = \"AS\";\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a string\n     *\n     * The given string can be in asplain, asdot or asdot+ representation format.\n     * {@see https://tools.ietf.org/html/rfc5396} for more information on\n     * the different ASN string representation\n     *\n     * @param {string} rawValue the asn string. In either asplain, asdot or asdot+ format\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromString(rawValue:string):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a numeric value\n     *\n     * @param {number} rawValue the asn numeric value\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromNumber(rawValue: number): Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a binary string\n     *\n     * @param {string} binaryString to create an ASN instance from\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromBinaryString(binaryString: string): Asn {\n        let validationResult = Validator.isValidBinaryString(binaryString);\n        if (validationResult[0]) {\n            return new Asn(parseInt(binaryString, 2))\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an instance of {@link ASN}\n     *\n     * @param {string | number} rawValue value to construct an ASN from. The given value can either be numeric or\n     * string. If in string then it can be in asplain, asdot or asdot+ string representation format\n     */\n    constructor(rawValue:string | number | bigint) {\n        super();\n        if (typeof rawValue === 'string') {\n            if (Asn.startWithASPrefix(rawValue)) {\n                this.value = BigInt(parseInt(rawValue.substring(2)));\n            } else if(rawValue.indexOf(\".\") != -1) {\n                this.value = BigInt(this.parseFromDotNotation(rawValue));\n            } else {\n                this.value = BigInt(parseInt(rawValue));\n            }\n        } else {\n            let valueAsBigInt = BigInt(rawValue);\n            let [isValid, message] = Validator.isValidAsnNumber(valueAsBigInt);\n            if (!isValid) {\n                throw Error(message.filter(msg => {return msg !== '';}).toString());\n            }\n            this.value = valueAsBigInt;\n        }\n    }\n\n    /**\n     * A string representation where the asn value is prefixed by \"ASN\". For example \"AS65526\"\n     *\n     * @returns {string} A string representation where the asn value is prefixed by \"ASN\"\n     */\n    toString():string {\n        let stringValue = this.value.toString();\n        return `${Asn.AS_PREFIX}${stringValue}`;\n    }\n\n    /**\n     * A string representation where the ASN numeric value of is represented as a string. For example \"65526\"\n     *\n     * @returns {string} A string representation where the ASN numeric value of is represented as a string\n     */\n    toASPlain():string {\n        return this.value.toString();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asplain notation if the ASN value is\n     * less than 65536 and uses asdot+ notation when the value is greater than 65536.\n     *\n     * For example 65526 will be represented as \"65526\" while 65546 will be represented as \"1.10\"\n     *\n     *\n     * @returns {string} A string representation of the ASN in either asplain or asdot+ notation depending on\n     * whether the numeric value of the ASN number is greater than 65526 or not.\n     */\n    toASDot():string {\n        if (this.value.valueOf() >= 65536n) {\n            return this.toASDotPlus();\n        }\n        return this.toASPlain();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asdot+ notation\n     *\n     * @returns {string} A string representation where the ASN value is represented using the asdot+ notation\n     *\n     */\n    toASDotPlus():string {\n        let high = this.value.valueOf() / 65535n;\n        let low = (this.value.valueOf() % 65535n) - high;\n        return `${high}.${low}`;\n    }\n\n    /**\n     * Converts the ASN value to binary numbers represented with strings\n     *\n     * @returns {string} a binary string representation of the value of the ASN number\n     */\n    toBinaryString():string {\n        return numberToBinaryString(this.value);\n    }\n\n    /**\n     * Checks if the ASN value is 16bit\n     *\n     * @returns {boolean} true if the ASN is a 16bit value. False otherwise.\n     */\n    is16Bit():boolean {\n        let [valid16BitAsnNumber,] = Validator.isValid16BitAsnNumber(this.value);\n        return valid16BitAsnNumber;\n    }\n\n    /**\n     * Checks if the ASN value is 32bit\n     *\n     * @returns {boolean} true if the ASN is a 32bit value. False otherwise.\n     */\n    is32Bit():boolean {\n        return !this.is16Bit();\n    }\n\n    /**\n     * Returns the next ASN number\n     *\n     * @returns {AbstractIPNum} the next ASN number\n     */\n    nextIPNumber(): AbstractIPNum {\n        return new Asn(this.value.valueOf() + 1n);\n    }\n\n    /**\n     * Returns the previous ASN number\n     *\n     * @returns {AbstractIPNum} the previous ASN number\n     */\n    previousIPNumber(): Asn {\n        return new Asn(this.value.valueOf() - 1n)\n    }\n\n    private static startWithASPrefix(word:string):boolean {\n        return word.indexOf(Asn.AS_PREFIX) === 0;\n    }\n\n    private parseFromDotNotation(rawValue: string): number {\n        let values: string[] = rawValue.split(\".\");\n        let high = parseInt(values[0]);\n        let low = parseInt(values[1]);\n        return (high * 65535) + (low + high);\n    }\n}\n\n\n/**\n * Represents an IPv6 number. A 128 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv6\n * @see https://www.rfc-editor.org/info/rfc8200\n */\nexport class IPv6 extends AbstractIPNum {\n    /**\n     * The decimal value represented by the IPv6 number in BigInt\n     */\n    readonly value: bigint;\n    /**\n     * The number of bits needed to represents the value of the IPv6 number\n     */\n    readonly bitSize: number = 128;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv6 number in BigInt\n     */\n    readonly maximumBitSize: bigint = Validator.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv6;\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The string character used to separate the individual hexadecatet when the IPv6 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual hexadecatet when rendered as strings\n     */\n    readonly separator: string = \":\";\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the decimal value of the IP number in BigInt\n     *\n     * @param {bigint} bigIntValue the decimal value of the IP number in BigInt\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBigInt(bigIntValue: bigint): IPv6 {\n        return new IPv6(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the IP number in hexadecatet notation. E.g\n     * \"2001:800:0:0:0:0:0:2002\"\n     *\n     * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more information on hexadecatet notation.\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromHexadecatet(ipString: string) : IPv6 {\n        return new IPv6(ipString);\n    }\n\n    /**\n     * Alias for IPv6.fromHexadecimalString\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromString(ipString: string) : IPv6 {\n        return IPv6.fromHexadecatet(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv6 number to be created\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv6 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            let paddedBinaryString = leftPadWithZeroBit(ipBinaryString, 128);\n            return new IPv6(parseBinaryStringToBigInt(paddedBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from an instance of {@link IPv4}\n     *\n     * @param {IPv4} ipv4 to create an IPv4-Compatible {@link IPv6} Address\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4(ipv4: IPv4): IPv6 {\n        return ipv4.toIPv4MappedIPv6();\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from a IPv4 represented in\n     * dot-decimal notation i.e. 127.0.0.1\n     *\n     * @param {IPv4} ip4DotDecimalString string represented in a dot decimal string\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4DotDecimalString(ip4DotDecimalString: string): IPv6 {\n        return new IPv4(ip4DotDecimalString).toIPv4MappedIPv6();\n    }\n\n    /**\n     * Constructor for an IPv6 number.\n     *\n     * @param {string | bigint} ipValue value to construct an IPv6 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in hexadecatet string notation\n     */\n    constructor(ipValue: string | bigint) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let expandedIPv6 = expandIPv6Number(ipValue);\n            let [value, hexadecatet] = this.constructFromHexadecimalDottedString(expandedIPv6);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n\n        } else {\n            let [value, hexadecatet] = this.constructFromBigIntValue(ipValue);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n        }\n    }\n\n    /**\n     * A string representation of the IPv6 number.\n     *\n     * @returns {string} The string representation of IPv6\n     */\n    public toString(): string {\n        let ipv6String = this.hexadecatet.map((value) => { return value.toString()}).join(\":\");\n        if (this.hexadecatet.length < 8) {\n            return \"::\" + ipv6String;\n        } else {\n            return ipv6String\n        }\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 number\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 number\n     */\n    //TODO maybe rename to something like getSegments? so it can be same with getOctet\n    public getHexadecatet():Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n\n    /**\n     * Returns the next IPv6 number\n     *\n     * @returns {IPv6} the next IPv6 number\n     */\n    public nextIPNumber(): IPv6 {\n        return IPv6.fromBigInt(this.getValue() + 1n)\n    }\n\n    /**\n     * Returns the previous IPv6 number\n     *\n     * @returns {IPv6} the previous IPv6 number\n     */\n    public previousIPNumber(): IPv6 {\n        return IPv6.fromBigInt(this.getValue() - 1n)\n    }\n\n    private constructFromBigIntValue(ipv6Number: bigint): [bigint, Array<Hexadecatet>]  {\n        let [isValid, message] = Validator.isValidIPv6Number(ipv6Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let binaryString = numberToBinaryString(ipv6Number);\n        return [ipv6Number, this.binaryStringToHexadecatets(binaryString)]\n    }\n\n    private constructFromHexadecimalDottedString(expandedIPv6: string): [bigint, Array<Hexadecatet>] {\n        let [isValid, message] = Validator.isValidIPv6String(expandedIPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals: string[] = expandedIPv6.split(\":\");\n        let hexadecatet: Hexadecatet[]  = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n        let value = BigInt(`0b${hexadectetNotationToBinaryString(expandedIPv6)}`);\n        return [value, hexadecatet];\n    }\n\n    private binaryStringToHexadecatets(binaryString: string): Hexadecatet[] {\n        let hexadecimalString = binaryStringToHexadecimalString(binaryString);\n        while (hexadecimalString.length % 4 != 0) {\n            hexadecimalString = '0' + hexadecimalString;\n        }\n        let hexadecimalStrings: string[] = hexadecimalString.match(/.{1,4}/g)!;\n        return hexadecimalStrings.map((stringHexadecatet)=> {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n    }\n}\n\n/**\n * The IPv4Mask can be seen as a specialized IPv4 number where, in a 32 bit number, starting from the left, you\n * have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it is used\n * to demarcate which bits are used to identify a network, and the ones that are used to identify hosts on the network\n */\nexport class IPv4Mask extends IPv4 {\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4Mask\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The decimal value represented by the IPv4 mask in BigInt\n     */\n    readonly value: bigint;\n\n    /**\n     * The cidr prefix represented by this mask\n     */\n    readonly prefix: number;\n\n    /**\n     * A convenience method for creating an instance of IPv4Mask. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in dot-decimal notation\n     * @returns {IPv4Mask} the instance of IPv4Mask\n     */\n    static fromDecimalDottedString(rawValue:string):IPv4Mask {\n        return new IPv4Mask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv4Mask.\n     * The passed strings need to be a valid IPv4 mask number in dot-decimal notation.\n     *\n     * @param {string} ipString The passed string in dot-decimal notation\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv4Mask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringOctets = ipString.split(\".\");\n        this.octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n\n        let binaryString = dottedDecimalNotationToBinaryString(ipString);\n        this.prefix  = (binaryString.match(/1/g) || []).length;\n        this.value = BigInt(`0b${binaryString}`);\n    }\n}\n\n/**\n * The IPv6Mask can be seen as a specialized IPv4 number where, in a 128 bit number, starting from the left,\n * you have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it\n * is used to demarcate which bits are used to identify a network, and the ones that are used to identify hosts\n * on the network\n */\nexport class IPv6Mask extends IPv6 {\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The decimal value represented by the IPv6 number in BigInt\n     */\n    readonly value: bigint;\n\n\n    /**\n     * The cidr prefix represented by this mask\n     */\n    readonly prefix: number;\n\n    /**\n     * A convenience method for creating an instance of IPv6Mask.\n     * The passed strings need to be a valid IPv4 mask number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in textual notation\n     * @returns {IPv6Mask} the instance of IPv6Mask\n     */\n    static fromHexadecatet(rawValue:string):IPv6Mask {\n        return new IPv6Mask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv6Mask.\n     * The passed strings need to be a valid IPv6 mask number in dot-decimal notation\n     *\n     * @param {string} ipString The passed IPv6 string\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        let expandedIPv6 = expandIPv6Number(ipString);\n        [isValid, message] = Validator.isValidIPv6Mask(expandedIPv6);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals = expandedIPv6.split(\":\");\n        this.hexadecatet = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet)\n        });\n\n        let binaryString = hexadectetNotationToBinaryString(expandedIPv6);\n        this.prefix  = (binaryString.match(/1/g) || []).length;\n        this.value = BigInt(`0b${binaryString}`);\n\n        this.value = BigInt(`0b${hexadectetNotationToBinaryString(expandedIPv6)}`);\n    }\n}\n\n/**\n * Check is the given IP number is an {@link IPv4} or not\n * @param ip the IP number to check if it is IPv4.\n */\nexport function isIPv4(ip: AbstractIPNum): ip is IPv4 {\n    return ip.bitSize === 32;\n}","import {AbstractIPNum, IPv4, IPv6, isIPv4} from \"./IPNumber\";\nimport {IPv4Prefix, IPv6Prefix} from \"./Prefix\";\nimport {\n    cidrPrefixToMaskBinaryString,\n    intLog2,\n    leftPadWithZeroBit,\n    matchingBitCount,\n    parseBinaryStringToBigInt\n} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport {IPNumType} from \"./IPNumType\";\n\n\nexport type IP<T> = T extends IPv4CidrRange ? IPv4 : IPv6;\n/**\n * Represents a continuous segment of either IPv4 or IPv6 numbers\n * without adhering to classless inter-domain routing scheme\n * for allocating IP addresses.\n */\nexport class RangedSet<T extends AbstractIPNum> implements Iterable<AbstractIPNum> {\n    readonly bitValue: bigint;\n    private readonly currentValue: T;\n    private readonly first: T;\n    private readonly last: T;\n\n    /**\n     * Convenience method for constructing an instance of {@link RangedSet} from a\n     * single IP number.\n     *\n     * @param ip The IP number, either IPv4 or IPv6 to construct the range from.\n     */\n    static fromSingleIP<T extends AbstractIPNum>(ip: T) {\n        return new RangedSet(ip, ip);\n    }\n    /**\n     * Convenience method for constructing an instance of {@link RangedSet} from an\n     * instance of either {@link IPv4CidrRange} or {@link IPv6CidrRange}\n     *\n     * @param cidrRange an instance of {@link RangedSet}\n     */\n    static fromCidrRange<U extends IPv6CidrRange | IPv4CidrRange>(cidrRange: U): RangedSet<IP<U>> {\n        return new RangedSet(\n            cidrRange.getFirst() as IP<U>,\n            cidrRange.getLast() as IP<U>\n        );\n    }\n\n    /**\n     * Convenience method for constructing an instance of {@link RangedSet} from\n     * a range string in the form of firstIp-lastIp\n     *\n     * @param rangeString  string in the form of firstIp-lastIp\n     */\n    static fromRangeString(rangeString: string) {\n        let ips = rangeString.split(\"-\").map(ip => ip.trim());\n\n        if (ips.length !== 2) {\n            throw new Error(\"Argument should be in the format firstip-lastip\");\n        }\n\n        let [firstIPString, lastIPString] = ips;\n\n        let [isValidFirstIPv4, ] = Validator.isValidIPv4String(firstIPString);\n        let [isValidSecondIPv4, ] = Validator.isValidIPv4String(lastIPString);\n\n        let [isValidFirstIPv6, ] = Validator.isValidIPv6String(firstIPString);\n        let [isValidLastIPv6, ] = Validator.isValidIPv6String(lastIPString);\n\n        if (isValidFirstIPv4 && isValidSecondIPv4) {\n            return new RangedSet(IPv4.fromDecimalDottedString(firstIPString), IPv4.fromDecimalDottedString(lastIPString))\n        } else if (isValidFirstIPv6 && isValidLastIPv6) {\n            return new RangedSet(IPv6.fromHexadecatet(firstIPString), IPv6.fromHexadecatet(lastIPString))\n        } else {\n            throw new Error(\"First IP and Last IP should be valid and same type\");\n        }\n    }\n\n    /**\n     * Constructor for an instance of {@link RangedSet} from an\n     * instance of either {@link IPv4CidrRange} or {@link IPv6CidrRange}\n     *\n     * Throws an exception if first IP number is not less than given last IP number\n     *\n     * @param first the first IP number of the range\n     * @param last the last IP number of the range\n     */\n    constructor(first: T, last: T) {\n        this.first = first;\n        this.last = last;\n        if (first.isGreaterThan(last)) {\n             throw new Error(`${first.toString()} should be lower than ${last.toString()}`)\n        }\n        this.currentValue = first;\n        this.bitValue = BigInt(first.bitSize);\n    }\n\n    /**\n     * Returns the first IP number in the range\n     */\n    getFirst(): T {\n        return this.first;\n    }\n\n    /**\n     * Returns the last IP number in the range\n     */\n    getLast(): T {\n        return this.last;\n    }\n\n    /**\n     * Returns the size, which is the number of IP numbers in the range.\n     */\n    getSize(): bigint {\n        return this.last.getValue() - (this.first.getValue()) + 1n;\n    }\n\n    /**\n     * Converts to a string representation of the range in the form of:\n     * <first-ip>-<last-ip>\n     */\n    toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n    /**\n     * Checks if this range is inside another range.\n     *\n     * @param otherRange the other range to check if this range is inside of.\n     */\n    public inside(otherRange: RangedSet<T>): boolean {\n        return otherRange.contains(this);\n    }\n\n    /**\n     * Checks if this range contains the given other range.\n     *\n     * @param otherRange the other range to check if this range contains\n     */\n    public contains(otherRange: RangedSet<T>): boolean {\n        let thisFirst: T = this.getFirst();\n        let thisLast: T = this.getLast();\n        let otherFirst: T = otherRange.getFirst();\n        let otherLast: T = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    /**\n     * Check if this range is equal to the given other range.\n     *\n     * @param otherRange the other range to check if equal to this range.\n     */\n    public isEquals(otherRange: RangedSet<T>): boolean {\n        return this.getFirst().isEquals(otherRange.getFirst())\n            && this.getLast().isEquals(otherRange.getLast());\n    };\n\n    /**\n     * Check if this range is less than the given range.\n     *\n     * @param otherRange the other range to check if less than.\n     */\n    public isLessThan(otherRange: RangedSet<T>): boolean {\n        if (this.isEquals(otherRange)) {\n            return false;\n        } else {\n            if (this.getFirst().isEquals(otherRange.getFirst())) {\n                return this.getSize() < (otherRange.getSize())\n            }\n            return this.getFirst().isLessThan(otherRange.getFirst());\n        }\n    }\n\n    /**\n     * Check if this range is greater than the given range.\n     *\n     * @param otherRange the other range to check if greater than.\n     */\n    public isGreaterThan(otherRange: RangedSet<T>): boolean {\n        if (this.isEquals(otherRange)) {\n            return false;\n        } else {\n            if (this.getFirst().isEquals(otherRange.getFirst())) {\n                return this.getSize() > (otherRange.getSize());\n            }\n            return this.getFirst().isGreaterThan(otherRange.getFirst());\n        }\n    }\n\n    /**\n     * Checks of this range overlaps with a given other range.\n     *\n     * This means it checks if part of a range is part of another range without\n     * being totally contained in the other range. Hence Equal or ranges contained inside one\n     * another are not considered as overlapping.\n     *\n     * @param otherRange the other range to check if it overlaps with this range.\n     */\n    public isOverlapping(otherRange: RangedSet<T>): boolean {\n        let thisFirst: T = this.getFirst();\n        let thisLast: T = this.getLast();\n        let otherFirst: T = otherRange.getFirst();\n        let otherLast: T = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(thisFirst)\n            ||\n            this.contains(otherRange)\n            ||\n            otherRange.contains(this)\n        );\n    }\n\n    /**\n     * Check if this range can be converted to a CIDR range.\n     */\n    public isCidrAble(): boolean {\n        if (this.getSize() === 1n) {\n            return true;\n        }\n        try {\n            let prefix = intLog2(this.getSize());\n            let netmask = parseBinaryStringToBigInt(\n                cidrPrefixToMaskBinaryString(prefix, isIPv4(this.currentValue) ? IPNumType.IPv4: IPNumType.IPv6)\n            );\n            return (this.first.getValue()) === (netmask & (this.first.getValue()));\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Converts an instance of range to an instance of CIDR range\n     */\n    public toCidrRange(): IPv4CidrRange | IPv6CidrRange {\n        if (isIPv4(this.currentValue)) {\n            return this.toIPv4CidrRange();\n        } else {\n            return this.toIPv6CidrRange();\n        }\n    };\n\n    /**\n     * Checks if this range is consecutive with another range.\n     *\n     * This means if the two ranges can be placed side by side, without any gap. Hence Equal\n     * or ranges contained inside one another, or overlapping ranges are not considered as consecutive.\n     *\n     * @param otherRange the other range to check if this range is consecutive to.\n     */\n    public isConsecutive(otherRange: RangedSet<T>): boolean {\n        let thisFirst: T = this.getFirst();\n        let thisLast: T = this.getLast();\n        let otherFirst: T = otherRange.getFirst();\n        let otherLast: T = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    /**\n     * Creates a range that is a union of this range and the given other range.\n     *\n     * @param otherRange the other range to combine with this range\n     */\n    public union(otherRange: RangedSet<T>): RangedSet<T> {\n        if (this.isEquals(otherRange)) {\n            return new RangedSet(otherRange.getFirst(), otherRange.getLast());\n        }\n\n        if (this.contains(otherRange)) {\n            return new RangedSet(this.getFirst(), this.getLast());\n        } else if(otherRange.contains(this)) {\n            return new RangedSet(otherRange.getFirst(), otherRange.getLast());\n        }\n\n        if (this.isOverlapping(otherRange)) {\n            if (this.getFirst().isLessThan(otherRange.getFirst())) {\n                return new RangedSet(this.getFirst(), otherRange.getLast());\n            } else {\n                return new RangedSet(otherRange.getFirst(), this.getLast());\n            }\n        }\n\n        throw new Error(\"Ranges do not overlap nor are equal\")\n    }\n\n    /**\n     * Prepends given range with this range.\n     * The last IP in the given range should be adjacent to the first IP in this range\n     *\n     * @param otherRange the other range to prepend\n     */\n    public prepend(otherRange: RangedSet<T>): RangedSet<T>  {\n        if (otherRange.getLast().nextIPNumber().isEquals(this.getFirst())) {\n            return new RangedSet(otherRange.getFirst(), this.getLast())\n        } else {\n            throw new Error(\"Range to prepend must be adjacent\")\n        }\n    }\n\n    /**\n     * Appends given range with this range.\n     * The last IP in this range should be adjacent to the first IP in range to append\n     *\n     * @param otherRange the other range to append\n     */\n    public append(otherRange: RangedSet<T>): RangedSet<T> {\n        if (this.getLast().nextIPNumber().isEquals(otherRange.getFirst())) {\n            return new RangedSet(this.getFirst(), otherRange.getLast());\n        } else {\n            throw new Error(\"Range to append must be adjacent\")\n        }\n    }\n\n    public subtract(otherRange: RangedSet<T>): RangedSet<T> {\n        if (!this.isOverlapping(otherRange)) {\n            throw new Error(\"Cannot subtract ranges that are not overlapping\")\n        }\n        if (!this.isLessThan(otherRange)) {\n            throw new Error(\"Cannot subtract a larger range from this range\")\n        }\n        return new RangedSet(this.getFirst(), otherRange.getLast());\n    }\n\n    /**\n     * Returns a sub range of a given size from this range.\n     *\n     * @param offset offset from this range where the subrange should begin\n     * @param size the size of the range\n     */\n    public takeSubRange(offset: bigint, size: bigint): RangedSet<AbstractIPNum> {\n        if (offset + (size) > (this.getSize())) {\n            throw new RangeError(\"Requested range is greater than what can be taken\");\n        }\n\n        if (size === (0n)) {\n            throw new Error(\"Sub range cannot be zero\");\n        }\n\n        let valueOfFirstIp = this.getFirst().value + (offset);\n        let firstIp: AbstractIPNum = isIPv4(this.getFirst()) ?\n            IPv4.fromNumber(valueOfFirstIp) : IPv6.fromBigInt(valueOfFirstIp);\n\n        let valueOfLastIp = firstIp.value + (size - 1n);\n        let lastIp = isIPv4(firstIp)? IPv4.fromNumber(valueOfLastIp) : IPv6.fromBigInt(valueOfLastIp);\n\n        return new RangedSet(firstIp, lastIp);\n    }\n\n    /**\n     * Performs a subtraction operation, where the passed range is removed from the original range.\n     *\n     * The return range from the subtraction operation could be a single or multiple ranges\n     *\n     * @param range\n     */\n    public difference(range: RangedSet<T>): Array<RangedSet<AbstractIPNum>> {\n        if (range.getSize() > (this.getSize())) {\n            throw new Error(\"Range is greater than range to be subtracted from\");\n        }\n\n        if (!this.contains(range)) {\n            throw new Error(\"Range to subtract is not contained in this range\");\n        }\n\n        let reminders = [];\n        try {\n            reminders.push(new RangedSet(this.getFirst(), range.getFirst().previousIPNumber()));\n        } catch (e) {}\n\n        try {\n            reminders.push(new RangedSet(range.getLast().nextIPNumber(), this.getLast()));\n        } catch (e) {}\n\n        return reminders;\n    }\n\n    public *take(count?: number): Iterable<AbstractIPNum> {\n        let computed: AbstractIPNum = this.getFirst();\n        let returnCount = count === undefined ? this.getSize().valueOf() : count;\n        while(returnCount > 0) {\n            returnCount--;\n            yield computed;\n            computed = computed.nextIPNumber();\n        }\n    }\n\n    *[Symbol.iterator](): IterableIterator<AbstractIPNum> {\n        yield* this.take()\n    }\n\n    private toIPv4CidrRange(): IPv4CidrRange {\n\n        let candidateRange = new IPv4CidrRange(IPv4.fromNumber(this.getFirst().getValue()),\n            IPv4Prefix.fromRangeSize(this.getSize()));\n        if (candidateRange.getFirst().isEquals(this.getFirst())) {\n            return candidateRange;\n        } else {\n            throw new Error(\"Range cannot be converted to CIDR\")\n        }\n\n    }\n\n    private toIPv6CidrRange(): IPv6CidrRange {\n        let candidateRange = new IPv6CidrRange(IPv6.fromBigInt(this.getFirst().getValue()),\n            IPv6Prefix.fromRangeSize(this.getSize()));\n        if (candidateRange.getFirst().isEquals(this.getFirst())) {\n            return candidateRange;\n        } else {\n            throw new Error(\"Range cannot be converted to CIDR\")\n        }\n    }\n}\n\n/**\n * Provides the implementation of functionality that are common to {@link IPv4CidrRange} and {@link IPv6CidrRange}\n */\nexport abstract class AbstractIPRange<T extends AbstractIPNum, P extends IPv4Prefix | IPv6Prefix>  implements Iterable<AbstractIPNum> {\n\n    abstract readonly bitValue: bigint;\n    protected abstract newInstance(num:T, prefix: IPv4Prefix | IPv6Prefix) : IPv4CidrRange | IPv6CidrRange;\n    abstract getFirst(): T\n    abstract getLast(): T\n    abstract getPrefix():P;\n    abstract getSize(): bigint;\n    abstract toCidrString(): string | never\n\n    public hasNextRange(): boolean {\n        let sizeOfCurrentRange = this.getSize();\n        return ((2n ** this.bitValue) - sizeOfCurrentRange) >= (this.getFirst().getValue() + (sizeOfCurrentRange))\n    }\n\n    public hasPreviousRange(): boolean {\n        return this.getSize() <= (this.getFirst().getValue())\n    }\n\n\n    public toRangeSet(): RangedSet<AbstractIPNum> {\n        return new RangedSet(this.getFirst(), this.getLast());\n    }\n\n    public inside(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        return this.toRangeSet().inside(otherRange.toRangeSet())\n    }\n\n    public contains(otherRange: IPv6CidrRange | IPv4CidrRange | AbstractIPNum): boolean {\n        if (otherRange instanceof AbstractIPNum) {\n            const firstValue = this.getFirst().getValue();\n            const lastValue = this.getLast().getValue();\n            const otherValue = otherRange.getValue();\n            return otherValue >= firstValue && otherValue <= lastValue;\n        }\n        return this.toRangeSet().contains(otherRange.toRangeSet());\n    }\n\n    public toRangeString(): string {\n        return this.toRangeSet().toRangeString();\n    }\n\n    public isOverlapping(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        return this.toRangeSet().isOverlapping(otherRange.toRangeSet());\n    }\n\n    public isConsecutive(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        return this.toRangeSet().isConsecutive(otherRange.toRangeSet());\n    }\n\n    public isCidrMergeable(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        const count = BigInt(matchingBitCount(this.getFirst().toBinaryString(), otherRange.getFirst().toBinaryString()));\n\n        if (this.getPrefix().value - count !== 1n) {\n            return false;\n        }\n\n        return this.isConsecutive(otherRange) && this.getSize() === (otherRange.getSize());\n    }\n\n    public isMergeable(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        return this.isCidrMergeable(otherRange)\n            || this.contains(otherRange)\n        || this.inside(otherRange);\n    }\n\n    public isEquals(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        return this.toRangeSet().isEquals(otherRange.toRangeSet());\n    }\n\n    public merge(otherRange: IPv6CidrRange | IPv4CidrRange): IPv6CidrRange | IPv4CidrRange {\n        if (!this.isCidrMergeable(otherRange)) {\n            throw new Error(`Cannot merge. Ranges (${this.toRangeString()},${otherRange.toRangeString()}) are not consecutive and/or of same size`)\n        }\n\n        return this.newInstance(this.getFirst(), this.getPrefix().merge());\n    }\n\n    /**\n     * Returns a lazily evaluated representation of the IP range that produces IP numbers by either:\n     *\n     * - iterating over using the for of syntax\n     * - converting to array using spread syntax\n     * - or assigning values to variables using deconstruction\n     *\n     * @param count the number of IP numbers to lazily evaluate.\n     * If none is given, the whole IP range is lazily returned.\n     */\n    public *takeStream(count?: number): Iterable<AbstractIPNum> {\n        return this.toRangeSet().take(count);\n    }\n\n    *[Symbol.iterator](): Iterator<AbstractIPNum> {\n        yield* this.toRangeSet();\n    }\n}\n\n/**\n * Represents a continuous segment of IPv4 numbers following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv4CidrRange extends AbstractIPRange<IPv4, IPv4Prefix> {\n    readonly bitValue: bigint = 32n;\n\n    /**\n     * Convenience method for constructing an instance of an IPv4CidrRange from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv4 number in CIDR notation\n     * @returns {IPv4CidrRange} the IPv4CidrRange\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv4CidrRange {\n        let [isValid, errorMessages] = Validator.isValidIPv4CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            let messages = errorMessages.filter(message => {return message !== ''});\n            throw new Error(messages.join(' and '));\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = BigInt(parseInt(cidrComponents[1]));\n        return new IPv4CidrRange(IPv4.fromDecimalDottedString(ipString), IPv4Prefix.fromNumber(prefix));\n    }\n\n    /**\n     * Constructor for creating an instance of an IPv4 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv4} ipv4 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv4Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IP number in other to create the range\n     */\n    constructor(private readonly ipv4: IPv4, readonly cidrPrefix: IPv4Prefix) {\n        super();\n    }\n\n    /**\n     * Gets the size of IPv4 numbers contained within the IPv4 range\n     *\n     * @returns {bigint} the amount of IPv4 numbers in the range\n     */\n    public getSize(): bigint {\n        return this.cidrPrefix.toRangeSize();\n    }\n\n    /**\n     * Method that returns the IPv4 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv4 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        let first = this.ipv4.toString();\n        return `${first.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv4 range in string notation where the first IPv4 number and last IPv4 number are\n     * separated by an hyphen. eg. 192.198.0.0-192.198.0.255\n     *\n     * @returns {string} the range in [first IPv4 number] - [last IPv4 number] format\n     */\n    public toRangeString(): string {\n        return super.toRangeString();\n    }\n\n\n    /**\n     * Method that returns the first IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the first IPv4 number in the IPv4 range\n     */\n    public getFirst(): IPv4 {\n        return IPv4.fromNumber(this.ipv4.getValue() & (this.cidrPrefix.toMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the last IPv4 number in the IPv4 range\n     */\n    public getLast(): IPv4 {\n        return last(this, this.ipv4) as IPv4\n    }\n\n    protected newInstance(num: IPv4, prefix: IPv4Prefix): IPv4CidrRange {\n        return new IPv4CidrRange(num, prefix)\n    }\n\n    public getPrefix(): IPv4Prefix {\n        return this.cidrPrefix;\n    }\n\n    /**\n     * Indicates whether the given IPv4 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range to compare with\n     * @returns {boolean} true if the two IPv4 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv4CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv4 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv4 range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv4CidrRange | AbstractIPNum): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv4CidrRange} otherRange he other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv4CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv4 ranges overlap\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv4CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv4 number from within an IPv4 range, starting from the first IPv4 number\n     *\n     * @param {bigint} count the amount of IPv4 number to take from the IPv4 range\n     * @returns {Array<IPv4>} an array of IPv4 number, taken from the IPv4 range\n     */\n    public take(count: bigint): Array<IPv4> {\n        let ipv4s: Array<IPv4>  = [this.getFirst()];\n        let iteratingIPv4 = this.getFirst();\n\n        if (count > (this.getSize())) {\n            let errMessage = Validator.takeOutOfRangeSizeMessage\n                .replace(\"$count\", count.toString())\n                .replace(\"$size\", this.getSize().toString());\n            throw new Error(errMessage);\n        }\n\n        for (let counter = 0; counter < count - 1n; counter++) {\n            ipv4s.push(iteratingIPv4.nextIPNumber());\n            iteratingIPv4 = iteratingIPv4.nextIPNumber();\n        }\n        return ipv4s;\n    }\n\n    /**\n     * Method that splits an IPv4 range into two halves\n     *\n     * @returns {Array<IPv4CidrRange>} An array of two {@link IPv4CidrRange}\n     */\n    public split() : Array<IPv4CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 32n) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv4Prefix.fromNumber(prefixToSplit + 1n);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv4CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv4CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    /**\n     * Method that split prefix into ranges of the given prefix,\n     * throws an exception if the size of the given prefix is larger than target prefix\n     *\n     * @param prefix the prefix to use to split\n     * @returns {Array<IPv4CidrRange>} An array of two {@link IPv4CidrRange}\n     */\n    public splitInto(prefix: IPv4Prefix): Array<IPv4CidrRange> {\n        let splitCount = prefix.getValue() - this.cidrPrefix.getValue()\n        if (splitCount < 0) {\n            throw new Error(\"Prefix to split into is larger than source prefix\")\n        } else if (splitCount === 0n) {\n            return [new IPv4CidrRange(this.getFirst(), prefix)]\n        } else if (splitCount === 1n) {\n            return this.split();\n        } else {\n            let results = this.split();\n            while (splitCount > 1) {\n                results = results.flatMap(result => result.split());\n                splitCount = splitCount - 1n;\n            }\n            return results\n        }\n    }\n\n    /**\n     * Returns true if there is an adjacent IPv4 cidr range of exactly the same size next to this range\n     */\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    /**\n     * Returns true if there is an adjacent IPv4 cidr range of exactly the same size previous to this range\n     */\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    /**\n     * Return the next IPv6 cidr range, or undefined if no next range\n     */\n    public nextRange(): IPv4CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue() + (sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfNextRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n\n    /**\n     * Return the previous IPv6 cidr range, or undefined if no next range\n     */\n    public previousRange(): IPv4CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue() - (sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfPreviousRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n}\n\n\n/**\n * Represents a continuous segment of IPv6 number following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv6CidrRange extends AbstractIPRange<IPv6, IPv6Prefix> {\n    readonly bitValue: bigint = 128n;\n\n    /**\n     * Convenience method for constructing an instance of an IPV6Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeInCidrNotation the range of the IPv6 number in CIDR notation\n     * @returns {IPv6CidrRange} the IPV6Range\n     */\n    static fromCidr(rangeInCidrNotation:string):IPv6CidrRange {\n        let [isValid, message] = Validator.isValidIPv6CidrNotation(rangeInCidrNotation);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let cidrComponents: Array<string> = rangeInCidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = BigInt(parseInt(cidrComponents[1]));\n        return new IPv6CidrRange(IPv6.fromHexadecatet(ipString), IPv6Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv6 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv6} ipv6 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv6Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IPv6 number in other to create the range\n     */\n    constructor(private readonly ipv6: IPv6, readonly cidrPrefix: IPv6Prefix) {\n        super();\n    }\n\n    /**\n     * Gets the size of IPv6 numbers contained within the IPv6 range\n     *\n     * @returns {bigint} the amount of IPv6 numbers in the range\n     */\n    public getSize(): bigint {\n        return this.cidrPrefix.toRangeSize();\n    }\n\n    /**\n     * Method that returns the IPv6 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv6 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        let first = this.ipv6.toString();\n        return `${first.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv6 range in string notation where the first IPv6 number and last IPv6 number are\n     * separated by an hyphen. eg. \"2001:db8:0:0:0:0:0:0-2001:db8:0:ffff:ffff:ffff:ffff:ffff\"\n     *\n     * @returns {string} the range in [first IPv6 number] - [last IPv6 number] format\n     */\n    public toRangeString(): string {\n        return super.toRangeString();\n    }\n\n    /**\n     * Method that returns the first IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the first IPv6 number in the IPv6 range\n     */\n    public getFirst(): IPv6 {\n        return IPv6.fromBigInt(this.ipv6.getValue() & (this.cidrPrefix.toMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the last IPv6 number in the IPv6 range\n     */\n    public getLast(): IPv6 {\n        return last(this, this.ipv6) as IPv6\n    }\n\n    protected newInstance(num: IPv6, prefix: IPv6Prefix): IPv6CidrRange {\n        return new IPv6CidrRange(num, prefix)\n    }\n\n    public getPrefix(): IPv6Prefix {\n        return this.cidrPrefix;\n    }\n\n    /**\n     * Indicates whether the given IPv6 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range to compare with\n     * @returns {boolean} true if the two IPv6 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv6CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv6 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv6 range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv6CidrRange | AbstractIPNum): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv6CidrRange} otherRange he other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv6CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv6 ranges overlap\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv6CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv6 number from within an IPv6 range, starting from the first IPv6 number\n     *\n     * @param {bigint} count the amount of IPv6 number to take from the IPv6 range\n     * @returns {Array<IPv6>} an array of IPv6 number, taken from the IPv6 range\n     */\n    public take(count: bigint): Array<IPv6> {\n        let iPv6s: Array<IPv6>  = [this.getFirst()];\n        let iteratingIPv6 = this.getFirst();\n\n        if (count > (this.getSize())) {\n            throw new Error(`${count.toString()} is greater than ${this.getSize().toString()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1n; counter++) {\n            iPv6s.push(iteratingIPv6.nextIPNumber());\n            iteratingIPv6 = iteratingIPv6.nextIPNumber();\n        }\n        return iPv6s;\n    }\n\n    /**\n     * Method that splits an IPv6 cidr range into two halves\n     *\n     * @returns {Array<IPv6CidrRange>} An array of two {@link IPv6CidrRange}\n     */\n    public split() : Array<IPv6CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 128n) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv6Prefix.fromNumber(prefixToSplit + 1n);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv6CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv6CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    /**\n     * Method that split prefix into ranges of the given prefix,\n     * throws an exception if the size of the given prefix is larger than target prefix\n     *\n     * @param prefix the prefix to use to split\n     * @returns {Array<IPv6CidrRange>} An array of two {@link IPv6CidrRange}\n     */\n    public splitInto(prefix: IPv6Prefix): Array<IPv6CidrRange> {\n        let splitCount = prefix.getValue() - this.cidrPrefix.getValue()\n        if (splitCount < 0) {\n            throw new Error(\"Prefix to split into is larger than source prefix\")\n        } else if (splitCount === 0n) {\n            return [new IPv6CidrRange(this.getFirst(), prefix)]\n        } else if (splitCount === 1n) {\n            return this.split();\n        } else {\n            let results = this.split();\n            while (splitCount > 1) {\n                results = results.flatMap(result => result.split());\n                splitCount = splitCount - 1n;\n            }\n            return results\n        }\n    }\n\n    /**\n     * Returns true if there is an adjacent IPv6 cidr range of exactly the same size next to this range\n     */\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    /**\n     * Returns true if there is an adjacent IPv6 cidr range of exactly the same size previous to this range\n     */\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    /**\n     * Return the next IPv6 cidr range, or undefined if no next range\n     */\n    public nextRange(): IPv6CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue() + (sizeOfCurrentRange);\n            return new IPv6CidrRange(new IPv6(startOfNextRange), this.cidrPrefix)\n        }\n        return;\n    }\n\n    /**\n     * Return the previous IPv6 cidr range, or undefined if no next range\n     */\n    public previousRange(): IPv6CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue() - sizeOfCurrentRange;\n            return new IPv6CidrRange(new IPv6(startOfPreviousRange), this.cidrPrefix)\n        }\n        return;\n    }\n}\n\n\n// utility functions shared by both IPv6CidrRange and IPv4CidrRange\nlet last = (range: IPv6CidrRange | IPv4CidrRange, ip: IPv6 | IPv4): IPv6 | IPv4 => {\n    let bitValue = Number(range.bitValue.valueOf());\n    let maskSize = BigInt(`0b${\"1\".repeat(bitValue)}`);\n    let maskAsBigInteger = range.cidrPrefix.toMask().getValue();\n    let invertedMask = leftPadWithZeroBit((maskAsBigInteger ^ (maskSize)).toString(2), bitValue);\n    if (isIPv4CidrRange(range)) {\n        return IPv4.fromNumber((ip.getValue()) | (parseBinaryStringToBigInt(invertedMask)))\n    } else {\n        return IPv6.fromBigInt((ip.getValue()) | (parseBinaryStringToBigInt(invertedMask)));\n    }\n}\n\nexport function isIPv4CidrRange<T>(ip: IPv6CidrRange | IPv4CidrRange): ip is IPv4CidrRange {\n    return ip.bitValue.valueOf() === 32n;\n}\n","import {expandIPv6Number} from \"./IPv6Utils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Converts a given bigint number to a hexadecimal string\n * @param num the bigint number\n * @returns {string} the hexadeciaml string\n */\nexport let bigIntToHexadecimalString = (num: bigint): string => {\n    return num.toString(16);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary string\n * @param {string} hexadecimalString the number in base 16\n * @returns {string} the number converted to base 2\n */\nexport let hexadecimalStringToBinaryString = (hexadecimalString: string) : string => {\n    let inDecimal = BigInt(`0x${hexadecimalString}`);\n    return inDecimal.toString(2);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary hexadecatet string.\n * This means the bits in the output cannot be more than 16\n *\n * @param hexadecimalString {string} the number converted to binary hexadecatet string\n */\nexport let hexadecimalStringToHexadecatetString = (hexadecimalString: string): string => {\n  let binaryString = hexadecimalStringToBinaryString(hexadecimalString);\n\n  let length = binaryString.length;\n  if (length > 16) {\n    throw new Error(\"Given decimal in binary contains digits greater than an Hexadecatet\")\n  }\n  return leftPadWithZeroBit(binaryString, 16);\n};\n\n/**\n * Given an IPv6 number in hexadecimal notated string, e.g 2001:0db8:0000:0000:0000:0000:0000:0000 converts it to\n * binary string\n *\n * @param hexadecimalString IPv6 string\n * @returns {string} the binary value of the given ipv6 number in string\n */\nexport let colonHexadecimalNotationToBinaryString = (hexadecimalString: string): string => {\n  let expandedIPv6 = expandIPv6Number(hexadecimalString);\n  let stringHexadecimal = expandedIPv6.split(\":\");\n\n  return stringHexadecimal.reduce((binaryAsString, hexidecimal) => {\n    return binaryAsString.concat(hexadecimalStringToHexadecatetString(hexidecimal))\n  }, '');\n};\n\n\n/**\n * Converts number in binary string to hexadecimal string\n * @param {string} num in binary string\n * @returns {string} num in hexadecimal string\n */\nexport let binaryStringToHexadecimalString = (num: string): string => {\n    // first convert to binary string to decimal (big Integer)\n    let inDecimal = BigInt(`0b${num}`);\n    return inDecimal.toString(16);\n};\n\n/**\n * Converts a given IPv6 number expressed in the hexadecimal string notation into a 16 bit binary number in string\n * @param {string} hexadectetString the IPv6 number\n * @returns {string} the IPv6 number converted to binary string\n */\nexport let hexadectetNotationToBinaryString = (hexadectetString: string): string => {\n  let expand = expandIPv6Number(hexadectetString);\n  let hexadecimals = expand.split(\":\");\n  return hexadecimals.reduce((hexadecimalAsString, hexavalue) => {\n    return hexadecimalAsString.concat(leftPadWithZeroBit(hexadecimalStringToBinaryString(hexavalue),16));\n  }, '');\n};","import {AbstractIPRange, IPv4CidrRange, IPv6CidrRange, RangedSet} from \"./IPRange\";\nimport {AbstractIPNum, IPv4, IPv6} from \"./IPNumber\";\nimport {IPv4Prefix, IPv6Prefix, isIPv4Prefix, Prefix} from \"./Prefix\";\n\ntype RangeType = RangedSet<IPv4> | RangedSet<IPv6>;\nexport type IPCidrRange<T> = T extends IPv4Prefix ? IPv4CidrRange : IPv6CidrRange;\nexport type IPCidrRangeArray<T> = T extends IPv4Prefix ? Array<IPv4CidrRange> : Array<IPv6CidrRange>;\n/**\n * Represents a collection of IP {@link RangedSet}'s\n */\nexport class Pool<T extends RangeType> {\n    private backingSet: SortedSet = new SortedSet();\n\n    /**\n     * Convenient method for creating an instance from arrays of {@link IPv4} or {@link IPv6}\n     * @param ipNumbers the arrays of {@link IPv4} or {@link IPv6} that will make up the pool.\n     */\n    public static fromIP(ipNumbers: Array<IPv4> | Array<IPv6>): Pool<RangeType> {\n        let ranges: Array<RangedSet<AbstractIPNum>> = (ipNumbers as Array<AbstractIPNum>).map((ip:(AbstractIPNum)) => {\n            return RangedSet.fromSingleIP(ip);\n        });\n\n        return new Pool(ranges);\n    }\n\n    /**\n     * Convenient method for creating an instance from arrays of {@link RangedSet}.\n     *\n     * @param ipRanges the arrays of {@link RangedSet}'s that will make up the pool.\n     */\n    // TODO: TSE: This makes it possible to create an instance containing both Range set of IPv4 and IPv6\n    public static fromRangeSet(ipRanges: Array<RangedSet<AbstractIPNum>>): Pool<RangeType> {\n        return new Pool(ipRanges);\n    }\n\n    /**\n     * Convenient method for creating an instance from arrays of {@link IPv4CidrRange} or {@link IPv6CidrRange}.\n     *\n     * @param cidrRanges the arrays of {@link IPv4CidrRange} or {@link IPv6CidrRange} that will make up the pool.\n     */\n    public static fromCidrRanges(cidrRanges: IPv4CidrRange[] | IPv6CidrRange[]) : Pool<RangeType> {\n        let cidr: Array<IPv4CidrRange | IPv6CidrRange> = cidrRanges as (IPv4CidrRange | IPv6CidrRange)[];\n        let rangeSet:RangedSet<AbstractIPNum>[] = cidr.map((range:IPv4CidrRange | IPv6CidrRange) => {\n            return range.toRangeSet();\n        })\n\n        return new Pool(rangeSet);\n    }\n\n    /**\n     * Constructor for an IP pool.\n     *\n     * Creates a Pool of IP ranges from supplied {@link RangedSet}'s\n     *\n     * @param ranges the array of IP ranges that would make up the pool.\n     */\n    constructor(ranges: Array<RangedSet<AbstractIPNum>>) {\n        ranges.forEach(range => {\n            this.backingSet.add(range);\n        })\n    }\n\n    /**\n     * Returns an array of {@link RangedSet}'s that is contained within the pool\n     */\n    public getRanges(): Array<RangedSet<AbstractIPNum>> {\n        return this.backingSet.asArray();\n    }\n\n    /**\n     * Returns an new {@link Pool} with all the IP ranges aggregated\n     */\n    public aggregate(): Pool<T> {\n        let sortedRanges:Array<RangedSet<AbstractIPNum>> = this.backingSet.asArray();\n        let mergedRanges = sortedRanges.reduce<Array<RangedSet<AbstractIPNum>>>\n        ((accumulator:Array<RangedSet<AbstractIPNum>>, currentRange: RangedSet<AbstractIPNum>, currentIndex: number, array: RangedSet<AbstractIPNum>[]) => {\n            if (accumulator.length == 0) {\n                accumulator.push(currentRange);\n                return accumulator;\n            } else {\n                let previous = accumulator.pop()!;\n                let previousCidrRange = previous.toCidrRange();\n                let currentCidrRange = currentRange.toCidrRange();\n\n                if (previousCidrRange.isCidrMergeable(currentCidrRange)) {\n                    let merged = previousCidrRange.merge(currentCidrRange);\n                    accumulator.push(merged.toRangeSet());\n                    return accumulator;\n                } else {\n                    if (!previous.contains(currentRange)) {\n                        accumulator.push(previous);\n                        accumulator.push(currentRange);\n                    } else {\n                        accumulator.push(previous);\n                    }\n                    return accumulator;\n                }\n            }\n        }, []);\n\n        let aggregatedPool = Pool.fromRangeSet(mergedRanges);\n        if (aggregatedPool.getRanges().length !== this.getRanges().length) {\n            return aggregatedPool.aggregate();\n        } else {\n            return aggregatedPool;\n        }\n    }\n\n    /**\n     * Gets a single range of size of the given prefix from pool.\n     * Only returns a range if there is a single range in the pool of same size or greater than given prefix.\n     *\n     * throws exception if the requested range cannot be got from the pool.\n     *\n     * @param prefix prefix range to retrieve\n     * TODO TSE\n     */\n    public getCidrRange<T extends IPv4Prefix | IPv6Prefix>(prefix: T): IPCidrRange<T> {\n        if (prefix.toRangeSize() > (this.getSize())) {\n            throw new Error(`Not enough IP number in the pool for requested prefix: ${prefix}`);\n        }\n        let selectedCidrRange: IPv4CidrRange | IPv6CidrRange | undefined;\n        let error: Error | undefined;\n\n        loop:\n        for (let range of this.getRanges()) {\n            for (let offset = 0n; offset + (prefix.toRangeSize()) <= (range.getSize()); offset = offset + 1n) try {\n                let selectedRange = range.takeSubRange(offset, prefix.toRangeSize());\n                selectedCidrRange = selectedRange.toCidrRange();\n                let remaining = range.difference(selectedRange);\n                this.removeExact(range);\n                this.add(remaining);\n                break loop;\n            } catch (e) {\n                if (e instanceof RangeError) {\n                    continue loop;\n                }\n                error = e instanceof Error ? e : new Error(String(e));\n            }\n        }\n\n        if (selectedCidrRange) {\n            return selectedCidrRange as IPCidrRange<T>;\n        } else {\n            throw (error === undefined ? new Error(`No range big enough in the pool for requested prefix: ${prefix}`) : error);\n        }\n    }\n\n    /**\n     * Gets a single or multiple ranges that fulfils the given prefix from the pool.\n     *\n     * throws exception if the requested range cannot be got from the pool.\n     *\n     * @param reqprefix prefix range to retrieve\n     */\n    public getCidrRanges<T extends IPv4Prefix | IPv6Prefix>(reqprefix: T): IPCidrRangeArray<T>  {\n        if (reqprefix.toRangeSize() > (this.getSize())) {\n            throw new Error(\"Prefix greater than pool\");\n        }\n        let go = (reqprefix: IPv4Prefix | IPv6Prefix,\n                  prefix: IPv4Prefix | IPv6Prefix,\n                  accummulated: AbstractIPRange<AbstractIPNum, IPv4Prefix | IPv6Prefix>[]): AbstractIPRange<AbstractIPNum, IPv4Prefix | IPv6Prefix>[] => {\n            try {\n                let singleCidrRange = this.getCidrRange(prefix);\n                accummulated.push(singleCidrRange);\n                let currentSize = accummulated.reduce((previous, current) => {\n                    return previous + (current.getSize());\n                }, 0n);\n                if (reqprefix.toRangeSize() === (currentSize)) {\n                    return accummulated as IPCidrRangeArray<T>;\n                } else {\n                    return go(reqprefix, prefix, accummulated)\n                }\n            } catch (e) {\n                let lowerPrefix = isIPv4Prefix(prefix) ?\n                    IPv4Prefix.fromNumber(prefix.getValue() + 1n) : IPv6Prefix.fromNumber(prefix.getValue() + 1n)\n                return go(reqprefix, lowerPrefix, accummulated);\n            }\n        }\n        return go(reqprefix, reqprefix, []) as IPCidrRangeArray<T>;\n    }\n\n    /**\n     * Returns the size of IP numbers in the pool\n     */\n    public getSize():  bigint {\n        return this\n            .aggregate()\n            .getRanges()\n            .reduce((previous, current) => {\n            return previous + current.getSize();\n        }, 0n);\n    }\n\n    /**\n     * Empties the pool and fill it with given ranges\n     *\n     * @param ipRanges the range to fill the pool with after emptying\n     */\n    public resetWith(ipRanges: Array<RangedSet<IPv4 | IPv6>>) {\n        this.backingSet.clear();\n        this.backingSet = this.backingSet.add(ipRanges);\n    }\n\n    /**\n     * Removes the given range from the pool. It only removes if the exact range exist in the pool.\n     * It is a Noop and returns false, if the given range does not exist in the pool. Returns true otherwise\n     *\n     * @param rangeToRemove range to remove from ppol\n     */\n    public removeExact(rangeToRemove: RangedSet<AbstractIPNum>): boolean {\n        let updatedSet = this.backingSet.removeExact(rangeToRemove);\n        let isUpdated = !this.backingSet.isEquals(updatedSet);\n        this.backingSet = updatedSet;\n        return isUpdated;\n    }\n\n    /**\n     * Removes the given range from the pool. If the given range overlaps, then it removes the overlapping portion.\n     * It is a Noop and returns false, if the given range does not exist in the pool. Returns true otherwise\n     *\n     * @param rangeToRemove range to remove from ppol\n     */\n    public removeOverlapping(rangeToRemove: RangedSet<AbstractIPNum>) {\n        let updatedSet = this.backingSet.removeOverlapping(rangeToRemove);\n        let isUpdated = !this.backingSet.isEquals(updatedSet);\n        this.backingSet = updatedSet;\n        return isUpdated;\n    }\n\n    /**\n     * Adds the given range to the pool.\n     *\n     * @param range to add to pool.\n     */\n    public add(range: Array<RangedSet<AbstractIPNum>>) {\n        this.backingSet = this.backingSet.add(range);\n    }\n\n    /**\n     * Removes all ranges from pool\n     */\n    public clear() {\n        this.backingSet.clear();\n    }\n}\n\ntype T = RangedSet<AbstractIPNum>;\nclass SortedSet {\n\n    public backingArray: Array<T>;\n\n    private sortArray(array: Array<T>): Array<T> {\n        array.sort((a:T, b:T) => {\n            if (a.isLessThan(b)) {\n                return -1;\n            }\n            if (a.isGreaterThan(b)) {\n                return 1;\n            }\n            return 0;\n        });\n\n        return array;\n    }\n\n    constructor()\n    constructor(array: Array<T>)\n    constructor(array?: Array<T>) {\n        if (array) {\n            this.backingArray = this.sortArray(array);\n        } else {\n            this.backingArray = new Array<T>()\n        }\n    }\n\n    public asArray(): Array<T> {\n        return this.backingArray;\n    }\n\n    public isEquals(other:SortedSet): boolean {\n        if (this.backingArray.length !== other.asArray().length) {\n            return false;\n        }\n        return this.backingArray.every((value, index) => {\n            return value.getSize() === (other.asArray()[index].getSize())\n        })\n    }\n\n    public add(item: Array<T>): SortedSet;\n    public add(item: T): SortedSet;\n    public add(item: T | Array<T>): SortedSet {\n        let array = this.backingArray;\n        if(\"push\" in item) {\n            array = array.concat(item);\n        } else {\n            array.push(item);\n        }\n        return new SortedSet(this.sortArray(array));\n    }\n\n    public removeExact(items: Array<T>): SortedSet;\n    public removeExact(items: T): SortedSet;\n    public removeExact(items: T | Array<T>): SortedSet {\n\n        let filtered = this.backingArray\n            .filter(currentItem => {\n                if (\"push\" in items) {\n                    return items.find(item => item.isEquals(currentItem)) !== undefined;\n                } else {\n                    return !items.isEquals(currentItem);\n                }\n            });\n\n        return new SortedSet(this.sortArray(filtered));\n    }\n\n    public removeOverlapping(items: Array<T>): SortedSet;\n    public removeOverlapping(items: T): SortedSet;\n    public removeOverlapping(items: T | Array<T>): SortedSet {\n\n        let filtered:Array<RangedSet<AbstractIPNum>> = this.backingArray\n            .flatMap(backingItem => {\n\n                if (\"push\" in items) {\n\n                    return items.flatMap(item => {\n                        if (backingItem.contains(item)) {\n                            return backingItem.difference(item);\n                        } else if (backingItem.inside(item)) {\n                            return new Array<RangedSet<IPv4 | IPv6>>();\n                        } else if (backingItem.isOverlapping(item)) {\n                            return [backingItem.subtract(item)];\n                        } else {\n                            return [item];\n                        }\n                    });\n\n                } else {\n                    try {\n                        return backingItem.difference(items);\n                    } catch (e) {\n                        return backingItem;\n                    }\n\n                }\n            });\n\n        return new SortedSet(this.sortArray(filtered));\n    }\n\n    public clear() {\n        this.backingArray = [];\n    }\n}","import {Validator} from \"./Validator\";\nimport {IPv4, IPv4Mask, IPv6, IPv6Mask} from \"./IPNumber\";\nimport {intLog2, parseBinaryStringToBigInt} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\n\n\ninterface Prefix {\n    value: bigint;\n    getValue(): bigint;\n    merge(): Prefix;\n    split(): Prefix;\n    toString(): string;\n    toRangeSize(): bigint\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv4 prefix portion represents the mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv4Prefix implements Prefix {\n    type: \"IPv4\" = \"IPv4\"\n    private readonly bitValue: bigint = 32n;\n    /**\n     * The decimal value of the 8bit number representing the prefix\n     */\n    value: bigint;\n\n    /**\n     * Convenience method for constructing an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    static fromNumber(rawValue: bigint):IPv4Prefix {\n        return new IPv4Prefix(rawValue);\n    };\n\n    static fromRangeSize(rangeSize: bigint) {\n        let prefixNumber = rangeSize === (1n) ? 32 : 32 - rangeSizeToPrefix(rangeSize, Validator.IPV4_SIZE);\n        return IPv4Prefix.fromNumber(BigInt(prefixNumber))\n    };\n\n    /**\n     * Constructor for an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    constructor(rawValue: bigint) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv4);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix\n     *\n     * @returns {number} the decimal value of the IPv4 prefix\n     */\n    public getValue(): bigint {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} The decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv4 prefix to a {@link IPv4Mask}\n     *\n     * The IPv4 mask is the representation of the prefix in the dot-decimal notation\n     *\n     * @returns {IPv4Mask} the mask representation of the prefix\n     */\n    public toMask(): IPv4Mask {\n        let onBits = '1'.repeat(Number(this.value));\n        let offBits = '0'.repeat(Number(32n - this.value));\n        return IPv4Mask.fromDecimalDottedString(this.toDecimalNotation(`${onBits}${offBits}`));\n    }\n\n    /**\n     * Returns the size (number of IP numbers) of range of this prefix\n     *\n     * @return {bigint} the size (number of IP numbers) of range of this prefix\n     */\n    public toRangeSize(): bigint {\n        /**\n         * Using bitwise shift operation this will be\n         * 1 << (this.bitValue - this.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return 1n << (this.bitValue - this.getValue())\n    }\n\n    /**\n     * Returns a prefix for when this prefix is merged\n     * with another prefix of the same size\n     */\n    merge(): IPv4Prefix {\n        return new IPv4Prefix(this.value - 1n);\n    }\n\n    /**\n     * Returns a prefix for when this prefix is split\n     * into two equal halves\n     */\n    split(): IPv4Prefix {\n        return new IPv4Prefix(this.value + 1n);\n    }\n\n    private toDecimalNotation(bits:string): string {\n        return `${parseBinaryStringToBigInt(bits.substr(0,8))}.${parseBinaryStringToBigInt(bits.substr(8,8))}.${parseBinaryStringToBigInt(bits.substr(16,8))}.${parseBinaryStringToBigInt(bits.substr(24,8))}`\n    }\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv6 prefix portion represents the mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 128 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv6Prefix implements Prefix {\n    type: \"IPv6\" = \"IPv6\"\n    private readonly bitValue: bigint = 128n;\n    /**\n     * The decimal value of the 16bit number representing the prefix\n     */\n    value: bigint;\n\n    /**\n     * Convenience method for constructing an instance of IPv46 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    static fromNumber(rawValue: bigint):IPv6Prefix {\n        return new IPv6Prefix(rawValue);\n    };\n\n    static fromRangeSize(rangeSize: bigint): IPv6Prefix {\n        let prefixNumber = rangeSize === (1n) ? 128 : 128 - rangeSizeToPrefix(rangeSize, Validator.IPV6_SIZE);\n        return IPv6Prefix.fromNumber(BigInt(prefixNumber))\n    }\n\n    /**\n     * Constructor for an instance of IPv6 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    constructor(rawValue: bigint) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv6 prefix\n     *\n     * @returns {number} the decimal value of the IPv6 prefix\n     */\n    public getValue(): bigint {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv6 prefix to a {@link IPv6Mask}\n     *\n     * The IPv6 mask is the representation of the prefix in 8 groups of 16 bit values represented in hexadecimal\n     *\n     * @returns {IPv6Mask} the mask representation of the prefix\n     */\n    public toMask(): IPv6Mask {\n        let onBits = '1'.repeat(Number(this.value));\n        let offBits = '0'.repeat(128 - Number(this.value));\n        return IPv6Mask.fromHexadecatet(this.toHexadecatetNotation(`${onBits}${offBits}`));\n    }\n\n    /**\n     * Returns the size (number of IP numbers) of range of this prefix\n     *\n     * @return {bigint} the size (number of IP numbers) of range of this prefix\n     */\n    public toRangeSize(): bigint {\n        /**\n         * Using bitwise shift operation this will be\n         * 1 << (this.bitValue - this.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return 1n << (this.bitValue - this.getValue())\n    }\n\n    /**\n     * Returns a prefix for when this prefix is merged\n     * with another prefix of the same size\n     */\n    merge(): IPv6Prefix {\n        return new IPv6Prefix(this.value - 1n);\n    }\n\n    /**\n     * Returns a prefix for when this prefix is split\n     * into two equal halves\n     */\n    split(): IPv6Prefix {\n        return new IPv6Prefix(this.value + 1n);\n    }\n\n    private toHexadecatetNotation(bits:string): string {\n        let binaryStrings: string[] = bits.match(/.{1,16}/g)!;\n        let hexadecimalStrings: Hexadecatet[] = binaryStrings.map((binaryString) => {\n            return Hexadecatet.fromString(binaryStringToHexadecimalString(binaryString));\n        });\n        return hexadecimalStrings.map((value) => { return value.toString()}).join(\":\");\n    }\n}\n\nfunction rangeSizeToPrefix(rangeSize: bigint,\n                           rangeMaxSize: bigint): number {\n    let ipType = rangeMaxSize > (Validator.IPV4_SIZE) ? \"IPv6\" : \"IPv4\";\n    if (rangeSize > (rangeMaxSize) || rangeSize === (0n)) {\n        throw new Error(Validator.invalidIPRangeSizeMessage.replace(\"$iptype\", ipType));\n    }\n\n    try {\n        return intLog2(rangeSize);\n    } catch (e) {\n        throw new Error(Validator.invalidIPRangeSizeForCidrMessage);\n    }\n}\n\n\n/**\n * Check is the given Prefix is an {@link IPv4Prefix} or not\n * @param prefix the IP prefix to check if it is IPv4Prefix.\n */\nfunction isIPv4Prefix(prefix: IPv4Prefix | IPv6Prefix): prefix is IPv4Prefix {\n    return prefix.type === \"IPv4\";\n}\n\n/**\n * Check is the given Prefix is an {@link IPv4Prefix} or not\n * @param prefix the IP prefix to check if it is IPv4Prefix.\n */\nfunction isIPv6Prefix(prefix: IPv4Prefix | IPv6Prefix): prefix is IPv6Prefix {\n    return prefix.type === \"IPv6\";\n}\n\nexport {Prefix, IPv4Prefix, IPv6Prefix, isIPv4Prefix}\n","'use strict';\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {cidrPrefixToMaskBinaryString} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {colonHexadecimalNotationToBinaryString} from \"./HexadecimalUtils\";\nimport {hexadectetNotationToBinaryString} from \"./HexadecimalUtils\";\n\nexport class Validator {\n    static IPV4_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/);\n    // source: https://community.helpsystems.com/forums/intermapper/miscellaneous-topics/5acc4fcf-fa83-e511-80cf-0050568460e4\n    static IPV6_PATTERN: RegExp = new RegExp(/^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/)\n    static IPV4_RANGE_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/)([1-9]|[1-2][0-9]|3[0-2])$/);\n    static IPV6_RANGE_PATTERN: RegExp = new RegExp(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/);\n    static IPV4_CONTIGUOUS_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,32}(0){0,32}$/);\n    static IPV6_CONTIGUOUS_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,128}(0){0,128}$/);\n\n    static EIGHT_BIT_SIZE: bigint = BigInt(`0b${\"1\".repeat(8)}`);\n    static SIXTEEN_BIT_SIZE: bigint = BigInt(`0b${\"1\".repeat(16)}`);\n    static THIRTY_TWO_BIT_SIZE: bigint = BigInt(`0b${\"1\".repeat(32)}`);\n    static ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE: bigint = BigInt(`0b${\"1\".repeat(128)}`);\n    static IPV4_SIZE = BigInt(\"4294967296\");\n    static IPV6_SIZE = BigInt(\"340282366920938463463374607431768211456\");\n\n    static invalidAsnRangeMessage = \"ASN number given less than zero or is greater than 32bit\";\n    static invalid16BitAsnRangeMessage = \"ASN number given less than zero or is greater than 16bit\";\n    static invalidIPv4NumberMessage = \"IPv4 number given less than zero or is greater than 32bit\";\n    static invalidIPv6NumberMessage = \"IPv6 number given less than zero or is greater than 128bit\";\n    static invalidOctetRangeMessage = \"Value given contains an invalid Octet; Value is less than zero or is greater than 8bit\";\n    static invalidHexadecatetMessage = \"The value given is less than zero or is greater than 16bit\";\n    static invalidOctetCountMessage = \"An IP4 number cannot have less or greater than 4 octets\";\n    static invalidHexadecatetCountMessage = \"An IP6 number must have exactly 8 hexadecatet\";\n    static invalidMaskMessage = \"The Mask is invalid\";\n    static invalidPrefixValueMessage = \"A Prefix value cannot be less than 0 or greater than 32\";\n    static invalidIPv4CidrNotationMessage = \"Cidr notation should be in the form [ip number]/[range]\";\n    static InvalidIPCidrRangeMessage = \"Given IP number portion must is not the start of the range\";\n    static invalidRangeNotationMessage = \"Range notation should be in the form [first ip]-[last ip]\";\n    static invalidRangeFirstNotGreaterThanLastMessage = \"First IP in [first ip]-[last ip] must be less than Last IP\";\n    static invalidIPv6CidrNotationString = \"A Cidr notation string should contain an IPv6 number and prefix\";\n    static takeOutOfRangeSizeMessage = \"$count is greater than $size, the size of the range\";\n    static cannotSplitSingleRangeErrorMessage = \"Cannot split an IP range with a single IP number\";\n    static invalidInetNumType = \"Given ipNumType must be either InetNumType.IPv4 or InetNumType.IPv6\";\n    static invalidBinaryStringErrorMessage = \"Binary string should contain only contiguous 1s and 0s\";\n    static invalidIPRangeSizeMessage = \"Given size is zero or greater than maximum size of $iptype\";\n    static invalidIPRangeSizeForCidrMessage = \"Given size can't be created via cidr prefix\";\n    static invalidIPv4PatternMessage = \"Given IPv4 is not confirm to a valid IPv6 address\";\n    static invalidIPv6PatternMessage = \"Given IPv6 is not confirm to a valid IPv6 address\";\n\n    /**\n     * Checks if given ipNumber is in between the given lower and upper bound\n     *\n     * @param ipNumber ipNumber to check\n     * @param lowerBound lower bound\n     * @param upperBound upper bound\n     * @returns {boolean} true if ipNumber is between lower and upper bound\n     */\n    private static isWithinRange(ipNumber: bigint, lowerBound: bigint, upperBound: bigint) : boolean {\n        return ipNumber >= lowerBound && ipNumber <= upperBound;\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an ASN number\n     *\n     * @param asnNumber the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidAsnNumber(asnNumber: bigint): [boolean, string[]] {\n        let isValid = this.isWithinRange(asnNumber, 0n, this.THIRTY_TWO_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalidAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the given ASN number is a 16bit ASN number\n     *\n     * @param {bigint} asnNumber to check if 16bit or not\n     * @returns {[boolean , string]} first value is true if valid 16bit ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValid16BitAsnNumber(asnNumber: bigint): [boolean, string[]] {\n        let isValid = Validator.isWithinRange(asnNumber, 0n, Validator.SIXTEEN_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalid16BitAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv4 number\n     *\n     * @param ipv4Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv4 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Number(ipv4Number: bigint | number): [boolean, string[]]  {\n        ipv4Number = typeof ipv4Number === \"bigint\" ? ipv4Number : BigInt(ipv4Number);\n        let isValid = this.isWithinRange(ipv4Number, 0n, this.THIRTY_TWO_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv4NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv6 number\n     *\n     * @param ipv6Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv6 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Number(ipv6Number: bigint): [boolean, string[]] {\n        let isValid = this.isWithinRange(ipv6Number, 0n, this.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv4 octet\n     *\n     * @param octetNumber the octet value\n     * @returns {boolean} true if valid octet, false otherwise\n     */\n    static isValidIPv4Octet(octetNumber: bigint): [boolean, string[]] {\n        let withinRange = this.isWithinRange(octetNumber, 0n, this.EIGHT_BIT_SIZE);\n        return [withinRange, withinRange ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv6 hexadecatet\n     *\n     * @param {bigint} hexadecatetNum the hexadecatet value\n     * @returns {[boolean , string]} first value is true if valid hexadecatet, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Hexadecatet(hexadecatetNum: bigint): [boolean, string[]] {\n        let isValid = this.isWithinRange(hexadecatetNum, 0n, this.SIXTEEN_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 value.\n     *\n     * @param {string} ipv4String the IPv4 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv4, second value\n     * contains error message if invalid IPv4\n     */\n    static isValidIPv4String(ipv4String: string): [boolean, string[]] {\n        let rawOctets = ipv4String.split(\".\");\n\n        if (rawOctets.length != 4 || rawOctets.includes('')) {\n            return [false, [Validator.invalidOctetCountMessage]];\n        }\n\n        let isValid = rawOctets.every(octet => {\n            return Validator.isNumeric(octet) ? Validator.isValidIPv4Octet(BigInt(octet))[0] : false;\n        });\n        if (!isValid) {\n            return [false, [Validator.invalidOctetRangeMessage]]\n        }\n\n        isValid = Validator.IPV4_PATTERN.test(ipv4String);\n        return [isValid, isValid? []: [Validator.invalidIPv4PatternMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 value.\n     *\n     * @param {string} ipv6String the IPv6 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv6, second value\n     * contains error message if invalid IPv6\n     */\n    static isValidIPv6String(ipv6String: string): [boolean, string[]] {\n        try {\n            let hexadecimals = expandIPv6Number(ipv6String).split(\":\");\n            if (hexadecimals.length != 8 ) {\n                return [false, [Validator.invalidHexadecatetCountMessage]]\n            }\n\n            let isValid = hexadecimals.every(hexadecimal => {\n                return Validator.isHexadecatet(hexadecimal) ?\n                    Validator.isValidIPv6Hexadecatet(BigInt(`0x${hexadecimal}`))[0] : false;\n            });\n            if (!isValid) {\n                return [false, [Validator.invalidHexadecatetMessage]]\n            }\n\n            isValid = Validator.IPV6_PATTERN.test(ipv6String);\n            return [isValid, isValid? []: [Validator.invalidIPv6PatternMessage]];\n        } catch (error) {\n            return [false, [String(error)]]\n        }\n    }\n\n    /**\n     * Checks if given value is a valid prefix value\n     *\n     * @param prefixValue value to check\n     * @param ipNumType The type of IP number\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidPrefixValue(prefixValue: bigint, ipNumType: IPNumType): [boolean, string[]] {\n        if (IPNumType.IPv4 === ipNumType) {\n            let withinRange = Validator.isWithinRange(BigInt(prefixValue), 0n, 32n);\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        if (IPNumType.IPv6 === ipNumType) {\n            let withinRange = Validator.isWithinRange(BigInt(prefixValue), 0n, 128n);\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        return [false, [Validator.invalidInetNumType]]\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 mask\n     *\n     * @param {string} ipv4MaskString the given IPv4 mask string\n     * @returns {[boolean , string]} first value is true if valid IPv4 mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Mask(ipv4MaskString: string) : [boolean, string[]] {\n        let ipv4InBinary = dottedDecimalNotationToBinaryString(ipv4MaskString);\n        let isValid = Validator.IPV4_CONTIGUOUS_MASK_BIT_PATTERN.test(ipv4InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidMaskMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 mask\n     *\n     * @param {string} ipv6MaskString the given IPv6 mask string\n     * @returns {[boolean , string]} first value is true if valid IPv6 mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Mask(ipv6MaskString: string) : [boolean, string[]] {\n        let ipv6InBinary = hexadectetNotationToBinaryString(ipv6MaskString);\n        let isValid = Validator.IPV6_CONTIGUOUS_MASK_BIT_PATTERN.test(ipv6InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidMaskMessage]];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv4 range in Cidr notation\n     *\n     * @param {string} ipv4RangeAsCidrString the IPv4 range in Cidr notation\n     *\n     * @returns {[boolean , string[]]} first value is true if valid IPv4 range in Cidr notation, false otherwise. Second\n     * value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4CidrNotation(ipv4RangeAsCidrString: string): [boolean, string[]] {\n        let cidrComponents = ipv4RangeAsCidrString.split(\"/\");\n        if(cidrComponents.length !== 2 || (cidrComponents[0].length === 0 || cidrComponents[1].length === 0)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let ip = cidrComponents[0];\n        let range = cidrComponents[1];\n\n        if (!/^\\d+$/.test(range)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        if (isNaN(Number(range))) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let [validIpv4, invalidIpv4Message] = Validator.isValidIPv4String(ip);\n        let [validPrefix, invalidPrefixMessage] = Validator.isValidPrefixValue(BigInt(range), IPNumType.IPv4);\n\n        let isValid = validIpv4 && validPrefix;\n        let invalidMessage = invalidIpv4Message.concat(invalidPrefixMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv4 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv4CidrNotation the IPv4 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n  static isValidIPv4CidrRange(ipv4CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv4CidrNotation, Validator.isValidIPv4CidrNotation, dottedDecimalNotationToBinaryString, (value: number) => cidrPrefixToMaskBinaryString(value, IPNumType.IPv4));\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv6 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv6CidrNotation the IPv6 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n    static isValidIPv6CidrRange(ipv6CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv6CidrNotation, Validator.isValidIPv6CidrNotation, colonHexadecimalNotationToBinaryString, (value: number) => cidrPrefixToMaskBinaryString(value, IPNumType.IPv6));\n    }\n\n\n    private static isValidCidrRange(rangeString: string,\n                                    cidrNotationValidator: (range:string) => [boolean, string[]],\n                                    toBinaryStringConverter: (range: string) => string,\n                                    prefixFactory: (num:number) => string): [boolean, string[]] {\n      let validationResult = cidrNotationValidator(rangeString);\n\n      if (!validationResult[0]) {\n        return validationResult\n      }\n\n      let cidrComponents = rangeString.split(\"/\");\n      let ip = cidrComponents[0];\n      let range = cidrComponents[1];\n      let ipNumber = BigInt(`0b${toBinaryStringConverter(ip)}`);\n      let mask = BigInt(`0b${prefixFactory(parseInt(range))}`);\n      let isValid = (ipNumber & (mask)) === (ipNumber);\n\n      return isValid ? [isValid, []]: [isValid, [Validator.InvalidIPCidrRangeMessage]];\n    }\n\n    static isValidIPv4RangeString(ipv4RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => BigInt(`0b${dottedDecimalNotationToBinaryString(firstIP)}`)\n            >= BigInt(`0b${dottedDecimalNotationToBinaryString(lastIP)}`);\n\n        return this.isValidRange(ipv4RangeString, Validator.isValidIPv4String, firstLastValidator);\n    }\n\n    static isValidIPv6RangeString(ipv6RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => BigInt(`0b${hexadectetNotationToBinaryString(firstIP)}`)\n            >= BigInt(`0b${hexadectetNotationToBinaryString(lastIP)}`);\n        return this.isValidRange(ipv6RangeString, Validator.isValidIPv6String, firstLastValidator);\n    }\n\n    private static isValidRange(rangeString: string,\n                                validator: (x:string) => [boolean, string[]],\n                                firstLastValidator: (first:string, last:string) => boolean):[boolean, string[]] {\n        let rangeComponents = rangeString.split(\"-\").map(component => component.trim());\n        if(rangeComponents.length !== 2 || (rangeComponents[0].length === 0 || rangeComponents[1].length === 0)) {\n            return [false, [Validator.invalidRangeNotationMessage]];\n        }\n        let firstIP = rangeComponents[0];\n        let lastIP = rangeComponents[1];\n\n        let [validFirstIP, invalidFirstIPMessage] = validator(firstIP);\n        let [validLastIP, invalidLastIPMessage] = validator(lastIP);\n\n        let isValid = validFirstIP && validLastIP;\n\n        if (isValid && firstLastValidator(firstIP, lastIP)) {\n            return [false, [Validator.invalidRangeFirstNotGreaterThanLastMessage]]\n        }\n\n        let invalidMessage = invalidFirstIPMessage.concat(invalidLastIPMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv6 range in Cidr notation\n     *\n     * @param {string} ipv6RangeAsCidrString the IPv6 range in Cidr notation\n     *\n     * @returns {[boolean , string]} first value is true if valid IPv6 range in Cidr notation, false otherwise.\n     * Second value contains \"valid\" or an error message when value is invalid\n     */\n    // TODO change to be like isValidIPv4CidrNotation where validation is done on the component of the cidr notation\n    // instead of a single regex check\n    static isValidIPv6CidrNotation(ipv6RangeAsCidrString: string): [boolean, string[]] {\n        let isValid = Validator.IPV6_RANGE_PATTERN.test(ipv6RangeAsCidrString);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6CidrNotationString]];\n    }\n\n    /**\n     * Checks if the given string is a binary string. That is contains only contiguous 1s and 0s\n     *\n     * @param {string} binaryString the binary string\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidBinaryString(binaryString: string): [boolean, string[]] {\n        if (/^([10])+$/.test(binaryString)) {\n            return [true, []]\n        } else {\n            return [false, [Validator.invalidBinaryStringErrorMessage]]\n        }\n    }\n\n    private static isNumeric(value: string): boolean {\n        return /^(\\d+)$/.test(value)\n    }\n\n    private static isHexadecatet(value: string): boolean {\n        return /^[0-9A-Fa-f]{4}$/.test(value)\n    }\n\n}\n\n","import {Validator} from \"./Validator\"\n\n/**\n * A binary representation of a 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Octet_(computing)} for more information on Octets\n *\n * An octet is used in the textual representation of an {@link IPv4} number, where the IP number value is divided\n * into 4 octets\n */\nexport class Octet {\n    private readonly value: number;\n\n    /**\n     * Convenience method for creating an Octet out of a string value representing the value of the octet\n     *\n     * @param {string} rawValue the octet value in string\n     * @returns {Octet} the Octet instance\n     */\n    static fromString(rawValue:string):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Convenience method for creating an Octet out of a numeric value representing the value of the octet\n     *\n     * @param {number} rawValue the octet value in number\n     * @returns {Octet} the Octet instance\n     */\n    static fromNumber(rawValue:number):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of an Octet.\n     *\n     * The constructor parameter given could either be a string or number.\n     *\n     * If a string, it is the string representation of the numeric value of the octet\n     * If a number, it is the numeric representation of the value of the octet\n     *\n     * @param {string | number} givenValue value of the octet to be created.\n     */\n    constructor(givenValue: string | number) {\n        let octetValue: number;\n        if (typeof givenValue === 'string') {\n            octetValue = parseInt(givenValue);\n        } else {\n            octetValue = givenValue;\n        }\n        let [isValid, message] = Validator.isValidIPv4Octet(BigInt(octetValue));\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = octetValue;\n    }\n\n    /**\n     * Method to get the numeric value of the octet\n     *\n     * @returns {number} the numeric value of the octet\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns a decimal representation of the value of the octet in string\n     *\n     * @returns {string} a decimal representation of the value of the octet in string\n     */\n    public toString(): string {\n        return this.value.toString(10);\n    }\n}","import {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\n\nlet extractPrefix = (ipv6String: string): string => {\n    return ipv6String.includes(\"/\") ? `/${ipv6String.split(\"/\")[1]}` : \"\"\n}\n\nexport let expandIPv6Number = (ipv6String:string):string => {\n    let expandWithZero = (hexadecimalArray: string[]): string => {\n        let paddedArray = hexadecimalArray.map((hexadecimal) => {\n            return leftPadWithZeroBit(hexadecimal, 4);\n        });\n\n        return paddedArray.join(\":\")\n    };\n\n    let expandDoubleColon = (gapCount: number): string => {\n        let pads = [];\n        for (let count=0; count<gapCount; count++) {\n            pads.push(\"0000\");\n        }\n        return pads.join(\":\");\n    };\n\n    if (/(:){3,}/.test(ipv6String)) throw \"given IPv6 contains consecutive : more than two\";\n\n    const prefix = extractPrefix(ipv6String);\n\n    if (ipv6String.includes(\"/\")) {\n        ipv6String = ipv6String.split(\"/\")[0]\n    }\n\n    let isValid = Validator.IPV6_PATTERN.test(ipv6String);\n    if (!isValid) {\n        throw Error(Validator.invalidIPv6PatternMessage)\n    }\n\n    if (ipv6String.includes(\"::\")) {\n        let split = ipv6String.split(\"::\");\n        let leftPortion = split[0];\n        let rightPortion = split[1];\n\n        let leftPortionSplit = leftPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let rightPortionSplit = rightPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let doublePortion = expandDoubleColon(8 - (leftPortionSplit.length + rightPortionSplit.length));\n\n\n        let leftString = expandWithZero(leftPortionSplit);\n        if (leftString !== \"\") {\n            leftString += \":\";\n        }\n\n\n        let rightString = expandWithZero(rightPortionSplit);\n        if (rightString !== \"\") {\n            rightString = \":\"+rightString;\n        }\n\n        return `${leftString}${doublePortion}${rightString}${prefix}`;\n\n    } else {\n        return `${expandWithZero(ipv6String.split(\":\"))}${prefix}`;\n    }\n};\n\n// Helper function to shorten hexadecatets\nconst shortenHexadecatet = (hex: string): string => {\n   // Input hex is expected to be like \"0000\", \"0DB8\", \"001A\" from expanded form\n   const withoutLeadingZero = hex.replace(/^0+/, '');\n   // If hex was \"0000\", withoutLeadingZero is \"\", so return \"0\"\n   // Otherwise, return the string without leading zeros.\n   return withoutLeadingZero === '' ? '0' : withoutLeadingZero;\n};\n\nexport let collapseIPv6Number = (ipv6String:string):string => {\n    const originalPrefix = extractPrefix(ipv6String);\n    const processedIPv6String = ipv6String.includes(\"/\") ? ipv6String.split(\"/\")[0] : ipv6String;\n\n    let expandedIPv6 = \"\";\n    try {\n        // Expand to full 8 segments, no prefix internally for processing\n        let tempExpanded = expandIPv6Number(processedIPv6String);\n        if (tempExpanded.includes(\"/\")) {\n            expandedIPv6 = tempExpanded.split(\"/\")[0];\n        } else {\n            expandedIPv6 = tempExpanded;\n        }\n    } catch (e) {\n        // Propagate error if expansion fails (e.g. invalid IPv6 format)\n        throw e;\n    }\n\n    let hexadecatets: string[] = expandedIPv6.split(\":\");\n\n    if (hexadecatets.length !== 8) {\n        // This case should ideally be prevented by expandIPv6Number's validation or structure.\n        // If expandIPv6Number guarantees 8 segments or throws, this might not be strictly needed.\n        // However, as a safeguard:\n        throw new Error(`Invalid IPv6 structure after expansion: ${expandedIPv6}. Expected 8 segments.`);\n    }\n\n    let zeroSequences: {start: number, length: number}[] = [];\n    let currentSequenceStart = -1;\n    let currentSequenceLength = 0;\n\n    for (let i = 0; i < 8; i++) {\n        // Segments from expandIPv6Number are 4-char 0-padded, e.g., \"0000\"\n        if (hexadecatets[i] === \"0000\") {\n            if (currentSequenceStart === -1) {\n                currentSequenceStart = i;\n            }\n            currentSequenceLength++;\n        } else {\n            if (currentSequenceLength > 0) {\n                zeroSequences.push({start: currentSequenceStart, length: currentSequenceLength});\n            }\n            currentSequenceStart = -1;\n            currentSequenceLength = 0;\n        }\n    }\n    if (currentSequenceLength > 0) { // Capture any trailing zero sequence\n        zeroSequences.push({start: currentSequenceStart, length: currentSequenceLength});\n    }\n\n    if (zeroSequences.length === 0) {\n        // No zero segments at all, just shorten each hexadecatet\n        return hexadecatets.map(shortenHexadecatet).join(\":\") + originalPrefix;\n    }\n\n    // Sort sequences: longest first, then earliest start first\n    zeroSequences.sort((a, b) => {\n        if (b.length !== a.length) {\n            return b.length - a.length;\n        }\n        return a.start - b.start;\n    });\n\n    const bestSequence = zeroSequences[0];\n\n    if (bestSequence.length === 8) { // All 8 segments are zero\n        return \"::\" + originalPrefix;\n    }\n\n    // RFC 5952: \"The symbol \"::\" MUST NOT be used to shorten just one 16-bit 0 field.\"\n    // So, length must be > 1 for \"::\" compression.\n    if (bestSequence.length < 2) {\n        // No \"::\" compression is applied (e.g. \"1:2:0:4:5:6:7:8\")\n        return hexadecatets.map(shortenHexadecatet).join(\":\") + originalPrefix;\n    }\n\n    // Apply \"::\" compression using the bestSequence\n    let leftPartSegments = hexadecatets.slice(0, bestSequence.start);\n    let rightPartSegments = hexadecatets.slice(bestSequence.start + bestSequence.length);\n\n    let leftString = leftPartSegments.map(shortenHexadecatet).join(\":\");\n    let rightString = rightPartSegments.map(shortenHexadecatet).join(\":\");\n\n    let finalStr = \"\";\n    if (bestSequence.start === 0) { // Compression at the beginning: \"::...\"\n        finalStr = \"::\" + rightString;\n    } else if (bestSequence.start + bestSequence.length === 8) { // Compression at the end: \"...::\"\n        // Ensure that if leftString is empty (which shouldn't happen here if start > 0), it's handled.\n        // However, if bestSequence.start > 0, leftPartSegments won't be empty unless bestSequence.start is 0.\n        finalStr = leftString + \"::\";\n    } else { // Compression in the middle: \"...::...\"\n        finalStr = leftString + \"::\" + rightString;\n    }\n\n    return finalStr + originalPrefix;\n};\n","import {Validator} from \"./Validator\";\n\n/**\n * A representation of a 4-digit hexadecimal number.\n *\n * It consists of four (base 16) number. ie FFFF\n *\n * It is used to represents the components of an IPv6 address\n */\nexport class Hexadecatet {\n    private readonly value: number;\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a four (base 16) number\n     * representation of a 16bit value.\n     *\n     * @param {string} rawValue the four (base 16) number\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromString(rawValue: string):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a decimal number representation\n     * of a 16 bit value\n     *\n     * @param {number} rawValue decimal number representation of a 16 bit value\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromNumber(rawValue: number):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of {@link Hexadecatet}\n     *\n     * @param {string | number} givenValue a string or numeric value. If given value is a string then it should be a\n     * four (base 16) number representation of a 16bit value. If it is a number, then it should be a decimal number\n     * representation of a 16 bit value\n     */\n    constructor(givenValue: string | number) {\n        let hexadecatetValue: number;\n        if (typeof givenValue === 'string') {\n            hexadecatetValue = parseInt(givenValue, 16);\n        } else {\n            hexadecatetValue = parseInt(String(givenValue), 16);\n        }\n\n        let [isValid, message] = Validator.isValidIPv6Hexadecatet(BigInt(hexadecatetValue));\n\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = hexadecatetValue;\n    }\n\n    /**\n     * Returns the numeric value in base 10 (ie decimal)\n     *\n     * @returns {number} the numeric value in base 10 (ie decimal)\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Returns the string representation of the base 16 representation of the value\n     * @returns {string} the string representation of the base 16 representation of the value\n     */\n    // TODO pad with a zero if digit is less than 4\n    public toString(): string {\n        return this.value.toString(16);\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(193);\n"],"names":["numberToBinaryString","num","toString","decimalNumberToOctetString","binaryString","length","Error","leftPadWithZeroBit","parseBinaryStringToBigInt","BigInt","dottedDecimalNotationToBinaryString","dottedDecimal","split","reduce","binaryAsString","octet","concat","parseInt","finalStringLength","repeat","cidrPrefixToMaskBinaryString","cidrPrefix","ipType","cidrUpperValue","intLog2","givenNumber","result","matchingBitCount","firstBinaryString","secondBinaryString","longerString","otherString","count","charAt","ip","bitSize","AbstractIPNum","getValue","this","value","toBinaryString","hasNext","maximumBitSize","hasPrevious","isEquals","anotherIPNum","isLessThan","isGreaterThan","isLessThanOrEquals","isGreaterThanOrEquals","IPv4","fromNumber","bigIntValue","fromDecimalDottedString","ipString","fromString","fromBinaryString","ipBinaryString","validationResult","Validator","isValidBinaryString","join","constructor","ipValue","super","THIRTY_TWO_BIT_SIZE","type","octets","separator","constructFromDecimalDottedString","constructFromBigIntValue","map","getOctets","nextIPNumber","previousIPNumber","toIPv4MappedIPv6","binary","IPv6","isValid","message","isValidIPv4String","filter","msg","rawOctet","Octet","ipv4Number","isValidIPv4Number","binaryStringToDecimalOctets","ipv4BinaryString","match","Asn","rawValue","startWithASPrefix","substring","indexOf","parseFromDotNotation","valueAsBigInt","isValidAsnNumber","stringValue","AS_PREFIX","toASPlain","toASDot","valueOf","toASDotPlus","high","is16Bit","valid16BitAsnNumber","isValid16BitAsnNumber","is32Bit","word","values","fromBigInt","fromHexadecatet","paddedBinaryString","fromIPv4","ipv4","fromIPv4DotDecimalString","ip4DotDecimalString","ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE","hexadecatet","expandedIPv6","expandIPv6Number","constructFromHexadecimalDottedString","ipv6String","getHexadecatet","ipv6Number","isValidIPv6Number","binaryStringToHexadecatets","isValidIPv6String","stringHexadecatet","Hexadecatet","hexadectetNotationToBinaryString","hexadecimalString","binaryStringToHexadecimalString","IPv4Mask","isValidIPv4Mask","stringOctets","prefix","IPv6Mask","isValidIPv6Mask","stringHexadecimals","RangedSet","fromSingleIP","fromCidrRange","cidrRange","getFirst","getLast","fromRangeString","rangeString","ips","trim","firstIPString","lastIPString","isValidFirstIPv4","isValidSecondIPv4","isValidFirstIPv6","isValidLastIPv6","first","last","currentValue","bitValue","getSize","toRangeString","inside","otherRange","contains","thisFirst","thisLast","otherFirst","otherLast","isOverlapping","isCidrAble","netmask","isIPv4","e","toCidrRange","toIPv4CidrRange","toIPv6CidrRange","isConsecutive","union","prepend","append","subtract","takeSubRange","offset","size","RangeError","valueOfFirstIp","firstIp","valueOfLastIp","lastIp","difference","range","reminders","push","take","computed","returnCount","undefined","Symbol","iterator","candidateRange","IPv4CidrRange","IPv4Prefix","fromRangeSize","IPv6CidrRange","IPv6Prefix","AbstractIPRange","hasNextRange","sizeOfCurrentRange","hasPreviousRange","toRangeSet","firstValue","lastValue","otherValue","isCidrMergeable","getPrefix","isMergeable","merge","newInstance","takeStream","fromCidr","rangeIncidrNotation","errorMessages","isValidIPv4CidrNotation","messages","cidrComponents","toRangeSize","toCidrString","toMask","ipv4s","iteratingIPv4","errMessage","takeOutOfRangeSizeMessage","replace","counter","prefixToSplit","splitCidr","firstIPOfFirstRange","firstRange","firstIPOfSecondRange","splitInto","splitCount","results","flatMap","nextRange","startOfNextRange","previousRange","startOfPreviousRange","rangeInCidrNotation","isValidIPv6CidrNotation","ipv6","iPv6s","iteratingIPv6","Number","maskSize","maskAsBigInteger","invertedMask","isIPv4CidrRange","bigIntToHexadecimalString","hexadecimalStringToBinaryString","hexadecimalStringToHexadecatetString","colonHexadecimalNotationToBinaryString","hexidecimal","hexadectetString","hexadecimalAsString","hexavalue","Pool","fromIP","ipNumbers","ranges","fromRangeSet","ipRanges","fromCidrRanges","cidrRanges","rangeSet","backingSet","SortedSet","forEach","add","getRanges","asArray","aggregate","mergedRanges","accumulator","currentRange","currentIndex","array","previous","pop","previousCidrRange","currentCidrRange","merged","aggregatedPool","getCidrRange","selectedCidrRange","error","loop","selectedRange","remaining","removeExact","String","getCidrRanges","reqprefix","go","accummulated","singleCidrRange","currentSize","current","lowerPrefix","isIPv4Prefix","resetWith","clear","rangeToRemove","updatedSet","isUpdated","removeOverlapping","sortArray","sort","a","b","backingArray","Array","other","every","index","item","items","filtered","currentItem","find","backingItem","rangeSize","prefixNumber","rangeSizeToPrefix","IPV4_SIZE","isValidPrefixValue","onBits","offBits","toDecimalNotation","bits","substr","IPV6_SIZE","toHexadecatetNotation","rangeMaxSize","invalidIPRangeSizeMessage","invalidIPRangeSizeForCidrMessage","isWithinRange","ipNumber","lowerBound","upperBound","asnNumber","invalidAsnRangeMessage","SIXTEEN_BIT_SIZE","invalid16BitAsnRangeMessage","invalidIPv4NumberMessage","invalidIPv6NumberMessage","isValidIPv4Octet","octetNumber","withinRange","EIGHT_BIT_SIZE","invalidOctetRangeMessage","isValidIPv6Hexadecatet","hexadecatetNum","invalidHexadecatetMessage","ipv4String","rawOctets","includes","invalidOctetCountMessage","isNumeric","IPV4_PATTERN","test","invalidIPv4PatternMessage","hexadecimals","invalidHexadecatetCountMessage","hexadecimal","isHexadecatet","IPV6_PATTERN","invalidIPv6PatternMessage","prefixValue","ipNumType","invalidPrefixValueMessage","invalidInetNumType","ipv4MaskString","ipv4InBinary","IPV4_CONTIGUOUS_MASK_BIT_PATTERN","invalidMaskMessage","ipv6MaskString","ipv6InBinary","IPV6_CONTIGUOUS_MASK_BIT_PATTERN","ipv4RangeAsCidrString","invalidIPv4CidrNotationMessage","isNaN","validIpv4","invalidIpv4Message","validPrefix","invalidPrefixMessage","invalidMessage","isValidIPv4CidrRange","ipv4CidrNotation","isValidCidrRange","isValidIPv6CidrRange","ipv6CidrNotation","cidrNotationValidator","toBinaryStringConverter","prefixFactory","InvalidIPCidrRangeMessage","isValidIPv4RangeString","ipv4RangeString","isValidRange","firstIP","lastIP","isValidIPv6RangeString","ipv6RangeString","validator","firstLastValidator","rangeComponents","component","invalidRangeNotationMessage","validFirstIP","invalidFirstIPMessage","validLastIP","invalidLastIPMessage","invalidRangeFirstNotGreaterThanLastMessage","ipv6RangeAsCidrString","IPV6_RANGE_PATTERN","invalidIPv6CidrNotationString","invalidBinaryStringErrorMessage","RegExp","IPV4_RANGE_PATTERN","cannotSplitSingleRangeErrorMessage","givenValue","octetValue","extractPrefix","expandWithZero","hexadecimalArray","leftPortion","rightPortion","leftPortionSplit","rightPortionSplit","doublePortion","gapCount","pads","expandDoubleColon","leftString","rightString","shortenHexadecatet","hex","withoutLeadingZero","collapseIPv6Number","originalPrefix","processedIPv6String","tempExpanded","hexadecatets","zeroSequences","currentSequenceStart","currentSequenceLength","i","start","bestSequence","leftPartSegments","slice","rightPartSegments","finalStr","hexadecatetValue","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}